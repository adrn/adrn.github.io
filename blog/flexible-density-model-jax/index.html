<!DOCTYPE html>
<html lang="en-us">
<head>

<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="description" content="Simple minimalist theme">
<meta name="keywords" content="minimalist,blog,goa,hugo,developer">

<title>
  apw - Flexible (stellar spatial) density models with Jax 
</title>

<meta name="generator" content="Hugo 0.89.0" />



<link rel="stylesheet" href="https://adrian.pw/css/github-syntax.css">


<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;1,300&family=Merriweather:wght@100;200;300;400;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css" integrity="sha384-DyZ88mC6Up2uqS4h/KRgHuoeGwBcD4Ng9SiP4dIRy0EXTlnuz47vAwmeGwVChigm" crossorigin="anonymous"/>
<link rel="stylesheet" href="https://adrian.pw/css/main.css">
<link rel="stylesheet" href="https://adrian.pw/css/custom.css">





<link rel="icon" type="image/png" href="../../img/favicon.ico" />


<link rel="manifest" href="../../manifest.json">

<meta name="theme-color" content="#ffffff">

</head>
<body lang="en-us">




<div class="wide-container">



<header class="text-left content-header">
  <h1 class="author"><a href="../../">Adrian Price-Whelan</a></h1>
</header>




<section id="menu-pane" class="menu text-center">
  
  <a class="menu-item" href="../../about/">about</a>
  
  <a class="menu-item" href="http://adrian.pw/cv/PriceWhelan-cv.pdf">cv</a>
  
  <a class="menu-item" href="../../blog/">blog</a>
  
  <a class="menu-item" href="../../research/">research</a>
  
  <a class="menu-item" href="../../viz/">visualizations</a>
  
</section>



<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
            showMathMenu: false, //disables context menu
            tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
           }
    });
</script>


<section id="content-pane" class="">
  <div class="col-md-12 text-justify content">
    
      <h2 class="title">Flexible (stellar spatial) density models with Jax:</h1>
    

    <p class="meta">
      
        2022-08-31
      
    </p>

    <p>A problem I have run into frequently in astronomical data analysis is the need to infer parameters of a density model where some aspects of the model are allowed to be flexible and other components are held more rigid. In these contexts, we are also sometimes interested in learning a flexible representation for the density of sources itself. This post demonstrates how to implement models with flexibility controlled by spline interpolation of function values in <a href="https://jax.readthedocs.io/en/latest/">JAX</a>.</p>
<p>One example of the need for flexibility in density modeling is the classic Galactic astronomy problem of measuring the vertical stellar density profile (and midplane density) of the Galactic disk: In this problem, we start with observations of stellar positions (<code>$x, y, z$</code>) (probably observed under some selection function) and we want to infer the midplane density value and a model for the density profile away from the midplane. Historically, simple, parametric density profiles have been used (e.g., <a href="https://ui.adsabs.harvard.edu/abs/2017MNRAS.470.1360B/abstract">Bovy et al. 2017</a>), but we now know that there are significant asymmetries in the density of stars (e.g., <a href="https://ui.adsabs.harvard.edu/abs/2019MNRAS.482.1417B/abstract">Bennett et al. 2019</a>), and so we might now want to fit a parametric density profile plus a model component to handle this asymmetry.</p>
<p>Another problem where the need to fit models with parametric and flexible components arises is in modeling the phase-space density of stellar streams (e.g., <a href="https://ui.adsabs.harvard.edu/abs/2019MNRAS.485.4726K/abstract">Koposov et al. 2019</a>, <a href="https://ui.adsabs.harvard.edu/abs/2022ApJ...925..118T/abstract">Tavangar et al. 2022</a>). In the case of stellar streams, we generally want to simultaneously fit the &ldquo;track&rdquo; or ridgeline of the stream in position and velocity components, the width of the stream, the density along the stream, and a flexible model for the background stellar density in these components.</p>
<p>There are many possible options for adding flexibility to models (see: Machine Learning). One particularly useful tool that is used heavily in time series analysis are <a href="https://en.wikipedia.org/wiki/Gaussian_process">Gaussian processes</a> (GPs). GPs allow adding controlled flexibility in probabilistic models (i.e. weakly parametric, through specification of a kernel function) and have gained popularity in astronomy recently thanks to advances in computational efficiency in computing GP likelihoods (e.g., <a href="https://github.com/exoplanet-dev/celerite2">celerite</a> or <a href="https://github.com/dfm/tinygp">tinygp</a>). I won&rsquo;t go over GPs in this post, but there are many resources available online and on GitHub that give great introductions to GPs (e.g., <a href="https://speakerdeck.com/dfm/an-astronomers-introduction-to-gaussian-processes-v2">Dan Foreman-Mackey&rsquo;s slides</a> or <a href="https://github.com/LSSTC-DSFP/LSSTC-DSFP-Sessions/blob/main/Sessions/Session13/Day2/answers/01-Introduction-to-GPs.ipynb">Rodrigo Luger&rsquo;s tutorial</a>).</p>
<p>In this post, we will use another frequently-used tool for specifying flexible models: <a href="https://en.wikipedia.org/wiki/Spline_(mathematics)">cubic splines</a>.</p>
<pre><code class="language-python"># Some global imports we will need throughout this post:
import astropy.units as u
import matplotlib as mpl
import matplotlib.pyplot as plt

# This ensures that JAX runs with 64-bit float precision by default:
from jax.config import config

config.update(&quot;jax_enable_x64&quot;, True)
import jax
import jax.numpy as jnp

%matplotlib inline
import numpy as np
</code></pre>
<h1 id="spline-models">Spline models</h1>
<p>A spline function is fully determined by the degree of the polynomial used, the location of <code>$M$</code> &ldquo;knots&rdquo; <code>$x_m$</code>, and the function value at the knots <code>$f_m$</code>. A common choice for the polynomial degree is 3, or cubic splines.</p>
<pre><code class="language-python">import scipy.interpolate as sci
</code></pre>
<pre><code class="language-python">rng = np.random.default_rng(seed=42)

M = 8
x_m = np.linspace(0, 10, M)
f_m = rng.uniform(-1, 1, M)
spl = sci.InterpolatedUnivariateSpline(x_m, f_m, k=3)  # k = the polynomial degree
</code></pre>
<pre><code class="language-python">plt.scatter(x_m, f_m)

grid = np.linspace(-1, 11, 1024)
plt.plot(grid, spl(grid), marker=&quot;&quot;, linestyle=&quot;-&quot;, color=&quot;tab:blue&quot;, zorder=-10)

plt.annotate(
    &quot;knots&quot;,
    xy=(x_m[0], f_m[0]),
    xytext=(2, 2),
    arrowprops=dict(color=&quot;#666&quot;, shrinkB=4, arrowstyle=&quot;-&gt;&quot;),
    ha=&quot;center&quot;,
)
for m in range(1, 3):
    plt.annotate(
        &quot;     &quot;,
        xy=(x_m[m], f_m[m]),
        xytext=(2, 2),
        arrowprops=dict(color=&quot;#666&quot;, shrinkB=4, arrowstyle=&quot;-&gt;&quot;),
        ha=&quot;center&quot;,
    )

plt.xlabel(&quot;$x$&quot;)
plt.ylabel(&quot;$f$&quot;)
</code></pre>
<pre><code>Text(0, 0.5, '$f$')
</code></pre>
<p><img src="output_5_1.png" alt="png"></p>
<p>The task of finding a spline representation of a function given samples or points is sometimes called &ldquo;spline regression.&rdquo; The problem is straightforward if we pick and fix locations for the knots of the spline function we want to fit and then add into our model the values of the function at the locations of the knots. This type of model has the advantage that the (spatial) scale of flexibility or &ldquo;degrees of freedom&rdquo; is controllable by setting the number of knots. However, unlike in GPs where kernel functions can be used to parametrize the amplitude or spatial scales of your problem, these things are not explicitly controlled in a spline model. One other disadvantage of a spline model is that the number of parameters in your model grows as you increase the number of knots (i.e. the degrees of freedom) of the model &ndash; this can make spline models intractable in some simple optimization routines (e.g., using <code>scipy.minimize</code> without gradient information) or in some Markov Chain Monte Carlo (MCMC) methods that do not use gradient information (e.g., Metropolis-Hastings or <a href="https://emcee.readthedocs.io/en/stable/"><code>emcee</code></a>).</p>
<p>Fortunately, it is possible to use spline models with <a href="https://jax.readthedocs.io/">JAX</a>, which automatically gives us access to functional gradients and therefore opens up the possibility of using optimization and sampling methods that perform well with large numbers of parameters. Below are two examples that demonstrate how to implement spline components in density models using JAX, to optimize the parameters of the models with <a href="https://jaxopt.github.io/"><code>jaxopt</code></a>, and to generate posterior samples using Hamiltonian Monte Carlo with <a href="https://blackjax-devs.github.io/blackjax/"><code>blackjax</code></a>.</p>
<h1 id="example-fitting-a-1d-density-profile-with-splines">Example: Fitting a 1D density profile with splines</h1>
<p>As a first demonstration of the idea, we are going to use simulated data to mock up a simpler version of the vertical density problem mentioned above. We will generate simulated data from a Gaussian, and then show how to fit the density distribution by modeling the points as an <a href="https://en.wikipedia.org/wiki/Poisson_point_process#Inhomogeneous_Poisson_point_process">inhomogeneous Poisson process</a> with either (1) a Gaussian or (2) a cubic spline density function. In either case, given a density function <code>$n(z)$</code> (Gaussian or spline), our likelihood and log-likelihood are given by the Poisson process likelihood, given all <code>$N$</code> of our <code>$z_n$</code> data points:</p>
<div>$$
\begin{align}
p(\left\{z_n\right\}_N \,|\, n(z)) &=
    \exp{\left[-\int {\rm d}z \, n(z)\right]} \, \prod_n^N n(z_n)
\end{align}
$$</div>
<h2 id="case-1-gaussian-model">Case 1: Gaussian model</h2>
<p>For our first demo, we will use a Gaussian to fit the data (which were generated by a Gaussian, so this is truly a toy example). In this case:</p>
<div>$$
\begin{align}
n(z \,|\, N_0, \mu, \sigma) &= N_0 \, \mathcal{N}(z \,|\, \mu, \sigma)\\
\mathcal{N}(x \,|\, \mu, \sigma) &= \frac{1}{\sqrt{2\pi\,\sigma^2}} \, e^{-\,\frac{(x - \mu)^2}{2\,\sigma^2}}\\
\end{align}
$$</div>
where `$\mathcal{N}$` represents the normal distribution, `$N_0$` is the total number of sources, and the mean `$\mu$` and standard deviation `$\sigma$` are the usual Gaussian parameters. 
<p>The integral that appears in the first term of the Poisson process likelihood above is therefore just the total number <code>$N_0$</code>, as the integral over the normal distribution <code>$\mathcal{N}$</code> is 1:</p>
<div>$$
\begin{align}
    p(\left\{z_n\right\}_N \,|\, N_0, \mu, \sigma) &= \exp{\left[-N_0 \, \int {\rm d}z \, \mathcal{N}(z)\right]}  \, \prod_n^N n(z_n)\\
    &= e^{-n_0}  \, N_0^N \, \prod_n^N \mathcal{N}(z_n \,|\, \mu, \sigma)\\
\end{align}
$$</div>
<p>The log-likelihood is therefore (where <code>$N$</code> is the number of data points, and <code>$N_0$</code> is a parameter):</p>
<div>$$
\begin{align}
\ln p(\left\{z_n\right\}_N \,|\, n_0, \mu, \sigma) &=
    -N_0 + N\,\ln N_0 + \sum_n^N \ln \mathcal{N}(z_n \,|\, \mu, \sigma)
\end{align}
$$</div>
<p>To start with, we will generate some random, normal distributed points with arbitrarily chosen mean and variance:</p>
<pre><code class="language-python">rng = np.random.default_rng(seed=42)

N = 100_000
z = rng.normal(0.03, 0.31, size=N)

# Pack the data into a dictionary so later we can store other metadata. For
# reasons that will be clear later, we also store the number of data points
# in this dictionary data structure:
data = {&quot;N&quot;: N, &quot;z&quot;: z}
</code></pre>
<p>Let&rsquo;s start by making a histogram of the &ldquo;data&rdquo; to visualize it:</p>
<pre><code class="language-python">z_bins = np.linspace(-2, 2, 128)
plt.hist(data[&quot;z&quot;], bins=z_bins)
plt.yscale(&quot;log&quot;)
plt.xlabel(&quot;$z$&quot;)
plt.ylabel(&quot;number of sources&quot;);
</code></pre>
<p><img src="output_11_0.png" alt="png"></p>
<p>To visualize an estimate of the density function, we can use the <code>numpy.histogram</code> function instead to compute the number counts per bin and divide by the size of each bin:</p>
<pre><code class="language-python">H, xe = np.histogram(data[&quot;z&quot;], bins=z_bins)
xc = 0.5 * (xe[:-1] + xe[1:])
dens = H / (xe[1] - xe[0])

plt.plot(xc, dens, drawstyle=&quot;steps-mid&quot;, marker=&quot;&quot;)
plt.yscale(&quot;log&quot;)

plt.xlabel(&quot;$z$&quot;)
plt.ylabel(&quot;density $n(z)$&quot;);
</code></pre>
<p><img src="output_13_0.png" alt="png"></p>
<p>In what follows, we are going to be defining several different density models and objective functions for our different density models. But ultimately, with all of these choices (e.g., Gaussian density model vs. cubic spline), we will need to be able to compute the log-likelihood given a choice of parameters. I like to use object-oriented programming (OOP) to structure my code when I am in situations like this because it helps to reduce duplicated code, enables encapsulation and namespacing, and, frankly, because I think the benefits of Python shine when using OOP. However, JAX is really designed to be used within a <a href="https://en.wikipedia.org/wiki/Functional_programming"><em>functional programming</em></a> context because of the way <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">Just-in-time</a> (JIT) compilation works. You can read a bit more about this in the <a href="https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html">JAX Gotchas</a> page, but the bottom line is that all JIT-compiled functions must be <em>pure functions</em> (functions that return the same values given the same input arguments).</p>
<p>There are some advanced ways of implementing more OOP-like code with JAX, but here I&rsquo;m going to (ab)use Python classes as a simple way of creating namespaces for the functions we will need with a light form of inheritance that still obeys the <em>pure function</em> requirement of JAX. These classes don&rsquo;t look like true OOP because we use <code>@classmethod</code>&rsquo;s instead of regular instance methods, but some other OOP ideas still translate. We will start by defining a base <code>Model</code> class that implements some common methods we will need for any of the density models we implement:</p>
<pre><code class="language-python"># We will need to wrap JAX's jit function with a partial function call to get
# it to work with our classmethod's below. We will use it to tell JAX to treat
# the 0'th input (i.e. the class itself in a classmethod) as a compile-time
# constant-valued object:
from functools import partial


class Model:
    # This will store the parameter names and expected sizes of the parameters
    # (to allow for array-valued parameters) for the density models we
    # implement later on:
    param_names = {}

    @classmethod
    @partial(jax.jit, static_argnums=(0,))
    def unpack_pars(cls, p_arr):
        &quot;&quot;&quot;
        This function takes a parameter array and unpacks it into a dictionary
        with the parameter names as keys.
        &quot;&quot;&quot;
        p_dict = {}
        j = 0
        for name, size in cls.param_names.items():
            p_dict[name] = jnp.squeeze(p_arr[j : j + size])
            j += size
        return p_dict

    @classmethod
    @partial(jax.jit, static_argnums=(0,))
    def pack_pars(cls, p_dict):
        &quot;&quot;&quot;
        This function takes a parameter dictionary and packs it into a JAX array
        where the order is set by the parameter name list defined on the class.
        &quot;&quot;&quot;
        p_arrs = []
        for name in cls.param_names.keys():
            p_arrs.append(jnp.atleast_1d(p_dict[name]))
        return jnp.concatenate(p_arrs)

    @classmethod
    @partial(jax.jit, static_argnums=(0,))
    def ln_posterior(cls, pars_arr, data, *args):
        pars = cls.unpack_pars(pars_arr)
        return cls.ln_likelihood(pars, data, *args) + cls.ln_prior(pars)

    @classmethod
    @partial(jax.jit, static_argnums=(0,))
    def objective(cls, pars_arr, N, data, *args):
        &quot;&quot;&quot;
        This function computes an objective function to be *minimized*: In our
        case, we will be doing Bayesian statistics, so this is generally the
        negative log-posterior-probability value such that if we minimize the
        objective function, we obtain the maximum a posteriori (MAP) parameter
        values. Here we also normalize the value by the number of data points so
        that scipy's minimizers don't run into overflow issues with the
        gradients.
        &quot;&quot;&quot;
        return -cls.ln_posterior(pars_arr, data, *args) / N
</code></pre>
<p>With our base <code>Model</code> class defined, we can now implement a subclass for the first model we are going to fit to our simulated data: a Gaussian! Using the true density model to fit the simulated data we should recover the input parameters that we used to generate the data:</p>
<pre><code class="language-python">def ln_normal(x, mu, var):
    &quot;&quot;&quot;Evaluate the log-normal probability&quot;&quot;&quot;
    return -0.5 * (jnp.log(2 * np.pi * var) + (x - mu) ** 2 / var)
</code></pre>
<pre><code class="language-python">class GaussianModel(Model):
    param_names = {
        &quot;ln_N0&quot;: 1,  # the log number density
        &quot;mean&quot;: 1,  # the mean of the Gaussian
        &quot;ln_std&quot;: 1,  # the log standard deviation
    }

    @staticmethod
    @jax.jit
    def ln_density(x, ln_N0, mean, ln_std):
        &quot;&quot;&quot;
        This function implements the log-density of our model. Here, this is the
        log-Gaussian.
        &quot;&quot;&quot;
        var = jnp.exp(2 * ln_std)
        return ln_N0 + ln_normal(x, mean, jnp.exp(2 * ln_std))

    @classmethod
    @partial(jax.jit, static_argnums=(0,))
    def ln_likelihood(cls, pars, data):
        &quot;&quot;&quot;
        Implementation of the log-likelihood for an inhomogeneous Poisson
        process with underlying density (rate) function given by a Gaussian.
        Here the integral over our density function is has a simple closed form
        solution (see the math above).
        &quot;&quot;&quot;
        dens = cls.ln_density(data[&quot;z&quot;], **pars)
        return -jnp.exp(pars[&quot;ln_N0&quot;]) + dens.sum()

    @classmethod
    @partial(jax.jit, static_argnums=(0,))
    def ln_prior(cls, pars):
        &quot;&quot;&quot;
        A very light prior on the parameters. We again use Normal's for priors,
        but for most parameters we use relatively wide (large variance) values
        so that the prior does not have much of an influence.
        &quot;&quot;&quot;
        lp = 0.0

        # A very wide, basically unconstrained Gaussian
        lp += ln_normal(pars[&quot;ln_N0&quot;], 0, 100)

        # We expect the mean to be close to 0
        lp += ln_normal(pars[&quot;mean&quot;], 0, 1)

        # We expect the standard deviation to be small:
        lp += ln_normal(pars[&quot;ln_std&quot;], -2, 3)

        return lp
</code></pre>
<p>Let&rsquo;s pick some initial values for our parameters and plot the density function corresponding to our parameter choices:</p>
<pre><code class="language-python">plt.plot(xc, dens, drawstyle=&quot;steps-mid&quot;, marker=&quot;&quot;)

init_pars = {&quot;ln_N0&quot;: np.log(N) + 0.5, &quot;mean&quot;: 1e-1, &quot;ln_std&quot;: np.log(0.3)}
init_p = GaussianModel.pack_pars(init_pars)

z_grid = np.linspace(z_bins.min(), z_bins.max(), 1024)
plt.plot(z_grid, np.exp(GaussianModel.ln_density(z_grid, **init_pars)), marker=&quot;&quot;)

plt.yscale(&quot;log&quot;)

plt.xlabel(&quot;$z$&quot;)
plt.ylabel(&quot;density $n(z)$&quot;);
</code></pre>
<pre><code>WARNING:absl:No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)
</code></pre>
<p><img src="output_20_1.png" alt="png"></p>
<p>Those initial parameter values don&rsquo;t look like a very good match to the observed density, but it&rsquo;s probably close enough that an optimizer will be able to find a better solution from there. For the optimizer, we will use Scipy&rsquo;s <a href="https://docs.scipy.org/doc/scipy/reference/optimize.minimize-lbfgsb.html">L-BFGS-B</a> implementation, which is available through the general-purpose <code>scipy.optimize.minimize()</code> function. Here we use JAX&rsquo;s <code>value_and_grad()</code> to get a function handle based on our objective function that returns both the objective value and the gradient with respect to the input parameters. This is where the utility of JAX comes to light: it uses auto-differentiation to compute the gradients for us. We have to set <code>jac=True</code> in <code>minimize()</code> to tell Scipy to expect the gradient along with the objective function value:</p>
<pre><code class="language-python">import scipy.optimize as sco
</code></pre>
<pre><code class="language-python">res = sco.minimize(
    jax.value_and_grad(GaussianModel.objective),
    GaussianModel.pack_pars(init_pars),
    args=(len(data[&quot;z&quot;]), data),
    jac=True,
    method=&quot;l-bfgs-b&quot;,
    options=dict(maxiter=1000),
    bounds=[(5, 20), (-2, 2), (-5, 5)],
)
res
</code></pre>
<pre><code>      fun: -10.261409577341759
 hess_inv: &lt;3x3 LbfgsInvHessProduct with dtype=float64&gt;
      jac: array([-1.03488418e-08,  2.31515273e-06, -1.50016197e-07])
  message: 'CONVERGENCE: NORM_OF_PROJECTED_GRADIENT_&lt;=_PGTOL'
     nfev: 10
      nit: 8
     njev: 10
   status: 0
  success: True
        x: array([11.5129243 ,  0.02868799, -1.16748798])
</code></pre>
<p>It looks like that optimization completed successfully, and after only 10 function evaluations! Let&rsquo;s look at the density function implied by the optimized parameters:</p>
<pre><code class="language-python">opt_pars = GaussianModel.unpack_pars(res.x)

plt.plot(xc, dens, drawstyle=&quot;steps-mid&quot;, marker=&quot;&quot;)

z_grid = np.linspace(z_bins.min(), z_bins.max(), 1024)
plt.plot(
    z_grid,
    np.exp(GaussianModel.ln_density(z_grid, **opt_pars)),
    marker=&quot;&quot;,
    color=&quot;tab:green&quot;,
)

plt.yscale(&quot;log&quot;)

plt.xlabel(&quot;$z$&quot;)
plt.ylabel(&quot;density $n(z)$&quot;);
</code></pre>
<p><img src="output_25_0.png" alt="png"></p>
<p>That looks like a pretty good fit! Let&rsquo;s move on to a more flexible example.</p>
<h2 id="case-2-spline-model">Case 2: Spline model</h2>
<p>We will now replace our density model <code>$n(z)$</code> with a cubic spline representation of the function. We will fix the location of the spline knots by using a hard-set, uniform grid of points in <code>$z$</code>, but the parameters of the model will then be the value of the (log-)density at the locations of the knots. Though there is no jax-ified cubic interpolation built-in to JAX itself (as far as I can tell, it currently only supports linear interpolation), we will use another package — <code>jax_cosmo</code> — which provides a jax-aware version of Scipy&rsquo;s <code>InterpolatedUnivariateSpline</code>:</p>
<pre><code class="language-python">from jax_cosmo.scipy.interpolate import InterpolatedUnivariateSpline
</code></pre>
<p>Awesome, we now have the main tool we need to enable implementing the spline model, however we have one more mathematical / numerical hurdle to solve: we need to be able to compute the integral of our density model to compute the first term in the Poisson process likelihood</p>
<div>$$
\exp{\left[-\int {\rm d}z \, n(z)\right]}
$$</div>
<p>For generic cubic splines, this integral over all <code>$z$</code>&rsquo;s is not finite. We therefore have to pick a domain over which to do this integral, and this then slightly changes the meaning of our parameter <code>ln_N0</code> to be the number of sources <em>in the domain we choose</em>. In practice, if we pick a domain that is large enough and the density function falls off quickly (as it does here), there won&rsquo;t be any practical difference. (But note: if you have a rigid selection region, or if you pick a domain that truncates the data, you have to be more careful than me!) Since our data end around <code>$z\sim \pm 1.5$</code>, we will pick a window of <code>$(-3, 3)$</code>.</p>
<p>We now need a way of computing the integral of our spline model over this domain. If our parameters were the value of the <em>density</em> <code>$N_0$</code> at the locations of the knots, we could use the <code>InterpolatedUnivariateSpline.integral()</code> method directly to compute the integral. However, we use the value of the log-density as parameters, so the integral is not as straightforward. Here, I&rsquo;ve implemented a version of <a href="https://en.wikipedia.org/wiki/Simpson%27s_rule">Simpson&rsquo;s rule</a> that takes in the log-function values and returns the log-integral, which is more stable than using other integration tools that would require first exponentiating the density and then taking the log of the estimated integral value on the outside:</p>
<pre><code class="language-python">def ln_simpson(ln_y, x):
    &quot;&quot;&quot;
    Evaluate the log of the definite integral of a function evaluated on a
    grid using Simpson's rule
    &quot;&quot;&quot;

    dx = jnp.diff(x)[0]
    num_points = len(x)
    if num_points // 2 == num_points / 2:
        raise ValueError(&quot;Because of laziness, the input size must be odd&quot;)

    weights_first = jnp.asarray([1.0])
    weights_mid = jnp.tile(jnp.asarray([4.0, 2.0]), [(num_points - 3) // 2])
    weights_last = jnp.asarray([4.0, 1.0])
    weights = jnp.concatenate([weights_first, weights_mid, weights_last], axis=0)

    return jax.scipy.special.logsumexp(ln_y + jnp.log(weights), axis=-1) + jnp.log(
        dx / 3
    )
</code></pre>
<p>With a decision about our integration window and a jax-ified function to compute the value of the log-integral over our spline density function, we can now set up a spline model to fit our toy data:</p>
<pre><code class="language-python">class GaussianSplineModel(Model):
    knots = jnp.linspace(-3, 3, 11)  # locations of the spline knots
    param_names = {
        &quot;ln_n0&quot;: 11,  # the value of the log-density at the knots
    }
    window = (-3, 3)  # integration window for numerical integral of density
    n_integral_pts = 1025  # the number of integration grid points to use

    @staticmethod
    @jax.jit
    def ln_density(x, ln_n0, knots):
        &quot;&quot;&quot;
        The log-density is just an evaluation of the spline at the input
        &quot;&quot;&quot;
        ln_dens_spl = InterpolatedUnivariateSpline(knots, ln_n0, k=3)
        return ln_dens_spl(x)

    @classmethod
    @partial(jax.jit, static_argnums=(0,))
    def ln_likelihood(cls, pars, data):
        &quot;&quot;&quot;
        Implementation of the log-likelihood for an inhomogeneous Poisson
        process with underlying density (rate) function given by a spline
        &quot;&quot;&quot;
        ln_dens = cls.ln_density(data[&quot;z&quot;], pars[&quot;ln_n0&quot;], cls.knots)

        # As mentioned above, to compute the integral over the density, we do
        # the integral numerically using Simpson's rule. For my implementation,
        # we must pass in a grid of points and the log of the function to
        # integrate evaluated at these grid points. The number of grid points is
        # hard-set here, but this should be tuned to meet some accuracy criteria
        V_grid = jnp.linspace(*cls.window, cls.n_integral_pts)
        ln_V = ln_simpson(cls.ln_density(V_grid, pars[&quot;ln_n0&quot;], cls.knots), V_grid)
        return -jnp.exp(ln_V) + ln_dens.sum()

    @classmethod
    @partial(jax.jit, static_argnums=(0,))
    def ln_prior(cls, pars):
        lp = 0.0
        for name, p in pars.items():
            lp += ln_normal(p, 0, 100).sum()
        return lp
</code></pre>
<p>With our spline model defined, our integration window set, and our knot locations fixed, we now need to initialize our parameters: the log-density values at the knot locations. We do this by interpolating the estimated density we got from the histogram above at the location of the knots:</p>
<pre><code class="language-python">knots = np.linspace(xc.min(), xc.max(), 11)
knots_ln_dens = sci.InterpolatedUnivariateSpline(xc, np.log(dens + 1e-8), k=3)(
    GaussianSplineModel.knots
)

plt.plot(xc, dens, drawstyle=&quot;steps-mid&quot;, marker=&quot;&quot;)
plt.scatter(
    GaussianSplineModel.knots,
    np.exp(knots_ln_dens),
    color=&quot;tab:blue&quot;,
    label=&quot;knots - initial&quot;,
)
plt.yscale(&quot;log&quot;)

plt.xlabel(&quot;$z$&quot;)
plt.ylabel(&quot;density $n(z)$&quot;)

plt.legend(loc=&quot;best&quot;)
</code></pre>
<pre><code>&lt;matplotlib.legend.Legend at 0x7ff53862b1c0&gt;
</code></pre>
<p><img src="output_33_1.png" alt="png"></p>
<p>We can now run the optimizer with our new spline model for the density:</p>
<pre><code class="language-python"># We add a little bit of random scatter just to make things interesting...
init_pars = {&quot;ln_n0&quot;: knots_ln_dens + rng.uniform(0, 0.1, size=len(knots))}
res = sco.minimize(
    jax.value_and_grad(GaussianSplineModel.objective),
    GaussianSplineModel.pack_pars(init_pars),
    args=(len(data[&quot;z&quot;]), data),
    jac=True,
    method=&quot;l-bfgs-b&quot;,
    options=dict(maxiter=1000, maxls=1000),  # I had to increase maxls to succeed
)
res
</code></pre>
<pre><code>      fun: -10.260887909516791
 hess_inv: &lt;11x11 LbfgsInvHessProduct with dtype=float64&gt;
      jac: array([-2.86425740e-06,  6.56002702e-06, -4.06564716e-05, -1.03612167e-05,
       -1.46661050e-06, -3.35053437e-06,  5.02995779e-06,  6.29047702e-06,
        1.88062757e-05, -6.78824477e-06, -1.25840325e-06])
  message: 'CONVERGENCE: REL_REDUCTION_OF_F_&lt;=_FACTR*EPSMCH'
     nfev: 37
      nit: 33
     njev: 37
   status: 0
  success: True
        x: array([-18.01096061, -19.45263838, -11.97307253,   2.68899672,
         9.73834031,  11.76439384,  10.06449883,   4.95208879,
        -4.7820572 , -21.05344694, -18.43766302])
</code></pre>
<p>Let&rsquo;s plot our optimized spline density function and the value at the knots over our data:</p>
<pre><code class="language-python">plt.plot(xc, dens, drawstyle=&quot;steps-mid&quot;, marker=&quot;&quot;)

opt_pars = GaussianSplineModel.unpack_pars(res.x)

_grid = np.linspace(*GaussianSplineModel.window, 1024)
plt.plot(
    _grid,
    np.exp(
        GaussianSplineModel.ln_density(
            _grid, opt_pars[&quot;ln_n0&quot;], GaussianSplineModel.knots
        )
    ),
    marker=&quot;&quot;,
    color=&quot;tab:green&quot;,
)
plt.scatter(
    GaussianSplineModel.knots,
    np.exp(opt_pars[&quot;ln_n0&quot;]),
    color=&quot;tab:blue&quot;,
    label=&quot;knots - optimized&quot;,
)

plt.yscale(&quot;log&quot;)

plt.xlabel(&quot;$z$&quot;)
plt.ylabel(&quot;density $n(z)$&quot;)

plt.legend(loc=&quot;best&quot;)
</code></pre>
<pre><code>&lt;matplotlib.legend.Legend at 0x7ff53ec7fd60&gt;
</code></pre>
<p><img src="output_37_1.png" alt="png"></p>
<p>Excellent - this also looks like a great fit! Unexpectedly, weird things happen outside of the range where we have data, but here the splines will largely be unconstrained.</p>
<p>Now that we have optimized parameters, and we have a model class with a function that computes the log-posterior probability given data, we can use the optimized parameter values to initialize an MCMC sampling of the parameters. To do this, we will use the <a href="https://blackjax-devs.github.io/blackjax/">blackjax</a> package to run a Hamiltonian Monte Carlo (HMC) sampler. In detail, we will use the NUTS sampler, and we will use their implementation of a window adaptation method to find good choices for the sampler parameters (step size and inverse mass matrix). This code follows the example code from the &ldquo;<a href="https://blackjax-devs.github.io/blackjax/examples/Introduction.html#nuts">quick introduction to blackjax</a>&rdquo; in the blackjax documentation.</p>
<pre><code class="language-python">import blackjax
</code></pre>
<pre><code class="language-python"># This is the main loop that does the sampling for us:
def inference_loop(rng_key, kernel, initial_state, num_samples):
    @jax.jit
    def one_step(state, rng_key):
        state, _ = kernel(rng_key, state)
        return state, state

    keys = jax.random.split(rng_key, num_samples)
    _, states = jax.lax.scan(one_step, initial_state, keys)

    return states
</code></pre>
<p>We start by using the blackjax implementation of STAN&rsquo;s window adaptation method to find good choices for the NUTS sampler parameters:</p>
<pre><code class="language-python">rng_key = jax.random.PRNGKey(42)

fn = jax.tree_util.Partial(GaussianSplineModel.ln_posterior, data=data)
warmup = blackjax.window_adaptation(
    blackjax.nuts,
    fn,
    1000,
)

state, kernel, _ = warmup.run(
    rng_key,
    res.x,
)
</code></pre>
<p>With a tuned kernel, we can now run our main inference loop to generate 1000 posterior samples of our parameters:</p>
<pre><code class="language-python">states = inference_loop(rng_key, kernel, state, 1_000)
</code></pre>
<p>Let&rsquo;s see how these look! As a quick check, let&rsquo;s look at a trace plot of a few of the parameters:</p>
<pre><code class="language-python">for i in [0, 5, 8]:
    plt.plot(states.position[:, i], marker=&quot;&quot;, drawstyle=&quot;steps-mid&quot;)

plt.xlabel(&quot;NUTS step&quot;)
plt.ylabel(&quot;parameter value&quot;)
</code></pre>
<pre><code>Text(0, 0.5, 'parameter value')
</code></pre>
<p><img src="output_46_1.png" alt="png"></p>
<p>Those look stable! Of course, we should compute some convergence statistics and check on the quality of our samples. But for now, we&rsquo;ll assume that our &ldquo;by-eye&rdquo; test is good enough, and proceed :).</p>
<p>For each posterior sample of our parameters, let&rsquo;s compute the implied density function and store these in a big 2D array:</p>
<pre><code class="language-python">_grid = np.linspace(*GaussianSplineModel.window, 1024)
ln_dens_samples = np.zeros((states.position.shape[0], len(_grid)))
for i, params in enumerate(states.position):
    ln_dens_samples[i] = GaussianSplineModel.ln_density(
        _grid, params, GaussianSplineModel.knots
    )
</code></pre>
<p>We can now visualize the 16–84th percentile range of our inferred density function:</p>
<pre><code class="language-python">plt.figure(figsize=(6, 5))
plt.fill_between(
    _grid,
    *np.percentile(np.exp(ln_dens_samples), [16, 84], axis=0),
    color=&quot;tab:blue&quot;,
    alpha=0.4,
    linewidth=0
)
plt.plot(
    _grid,
    np.median(np.exp(ln_dens_samples), axis=0),
    color=&quot;tab:blue&quot;,
    linewidth=2,
    marker=&quot;&quot;,
)
plt.yscale(&quot;log&quot;)

plt.xlabel(&quot;$z$&quot;)
plt.ylabel(&quot;density $n(z)$&quot;);
</code></pre>
<p><img src="output_50_0.png" alt="png"></p>
<p>As we might expect, the density function is not well constrained beyond <code>$|z|\gtrsim 2$</code> or so where we do not have data.</p>
<p>Now that we have a better picture of how to implement these types of flexible spline models with JAX, let&rsquo;s turn to a more complicated science example.</p>
<hr>
<h1 id="example-fitting-the-density-profile-and-track-of-a-stellar-stream">Example: Fitting the density profile and track of a stellar stream</h1>
<p>Building off of the 1D spline model we used above, we are now going to move on to a more complicated example motivated by my own research. Here we will try to model the 2D (on sky) density of a <a href="https://en.wikipedia.org/wiki/Stellar_kinematics#Stellar_streams">stellar stream</a> known as the &ldquo;GD-1 stream&rdquo; (named after its discovers <a href="https://ui.adsabs.harvard.edu/abs/2006ApJ...643L..17G/abstract">Grillmair &amp; Dionatos</a>). There is too much context to cover here, but for the purposes of this demo, assume that we are given a list of sky positions of stars from Gaia and we would like to model the on-sky density of the stream and background to (a) characterize the track of the stream, and (b) identify probable member stars. (The stars we will use have actually been pre-filtered to select distant, low-metallicity, main-sequence stars with proper motions that match the <a href="https://ui.adsabs.harvard.edu/abs/2018ApJ...863L..20P/abstract">previously-fit track of the stream</a>)</p>
<p>Let&rsquo;s start by loading the data, which is included in this repository as a FITS file, so we can load the catalog using <a href="https://docs.astropy.org/en/stable/table/index.html"><code>astropy.table</code></a>:</p>
<pre><code class="language-python">import astropy.table as at
</code></pre>
<pre><code class="language-python">gd1_tbl = at.Table.read(&quot;data/gd1-gaiadr3-blog.fits&quot;)

# We will apply one additional selection criteria to limit the number of stars we have to handle:
gd1_tbl = gd1_tbl[gd1_tbl[&quot;gd1_phi2&quot;] &gt; -7]
len(gd1_tbl)
</code></pre>
<pre><code>2960
</code></pre>
<p>The table contains many columns from <a href="https://gea.esac.esa.int/archive/">Gaia DR3</a>, along with some photometry from the Pan-STARS PS1 survey (<a href="https://mastweb.stsci.edu/">data release 2</a>):</p>
<pre><code class="language-python">gd1_tbl.colnames
</code></pre>
<pre><code>['source_id',
 'ra',
 'dec',
 'parallax',
 'parallax_error',
 'pmra',
 'pmra_error',
 'pmdec',
 'pmdec_error',
 'ra_parallax_corr',
 'ra_pmra_corr',
 'ra_pmdec_corr',
 'dec_parallax_corr',
 'dec_pmra_corr',
 'dec_pmdec_corr',
 'parallax_pmra_corr',
 'parallax_pmdec_corr',
 'pmra_pmdec_corr',
 'phot_g_mean_mag',
 'phot_g_mean_flux_over_error',
 'phot_bp_mean_mag',
 'phot_bp_mean_flux_over_error',
 'phot_rp_mean_mag',
 'phot_rp_mean_flux_over_error',
 'ruwe',
 'gd1_phi1',
 'gd1_phi2',
 'objID',
 'raMean',
 'decMean',
 'nDetections',
 'ng',
 'nr',
 'ni',
 'nz',
 'ny',
 'gMeanPSFMag',
 'rMeanPSFMag',
 'iMeanPSFMag',
 'zMeanPSFMag',
 'yMeanPSFMag',
 'gMeanPSFMagErr',
 'rMeanPSFMagErr',
 'iMeanPSFMagErr',
 'zMeanPSFMagErr',
 'yMeanPSFMagErr',
 'sep_arcsec']
</code></pre>
<p>However, the only two columns we will use here are <code>gd1_phi1</code> and <code>gd1_phi2</code>, which are the sky positions of stars in a coordinate system in which the GD-1 stream lies approximately along latitude=0 (the coordinate system was defined in Koposov et al. 2010 and is implemented as an <code>astropy.coordinates</code> frame in the <a href="https://gala.adrian.pw">gala</a> package in <a href="http://gala.adrian.pw/en/latest/api/gala.coordinates.GD1Koposov10.html">gala.coordinates</a>).</p>
<p>Let&rsquo;s start by making a scatter plot of the sky positions:</p>
<pre><code class="language-python">fig, ax = plt.subplots(figsize=(12, 3), constrained_layout=True)
ax.plot(
    gd1_tbl[&quot;gd1_phi1&quot;],
    gd1_tbl[&quot;gd1_phi2&quot;],
    marker=&quot;o&quot;,
    markeredgewidth=0,
    markersize=3.0,
    ls=&quot;none&quot;,
    alpha=0.25,
)
ax.set_xlim(-100, 20)
ax.set_ylim(-7, 5)

ax.set_xlabel(&quot;$\phi_1$ [deg]&quot;)
ax.set_ylabel(&quot;$\phi_2$ [deg]&quot;);
</code></pre>
<p><img src="output_58_0.png" alt="png"></p>
<h2 id="defining-the-density-model">Defining the density model</h2>
<p>The curved over-density of stars that arcs from <code>$(\phi_1, \phi_2) \sim (-80, -3)^\circ$</code> to <code>$(\phi_1, \phi_2) \sim (-40, 0)^\circ$</code> to <code>$(\phi_1, \phi_2) \sim (0, -2)^\circ$</code> is the GD-1 stream. This is the density distribution we would like to model using a flexible, spline-based density function. Given the complexity of the stream, we will clearly have to be a bit more baroque in our model specification relative to the previous example. Additionally, there is a non-negligible background density of stars that varies (more smoothly) over the sky region where the stream exists: we will have to simultaneously model this background distribution:</p>
<ul>
<li>To represent the background, we will assume that the density is only a function of <code>$\phi_1$</code> and can be represented as a spline with evenly-spaced knots between <code>$\phi_1 \in [-120, 40]^\circ$</code>.</li>
<li>To represent the amplitude of the density of the stream, we will again use a spline as a function of <code>$\phi_1$</code> with equally-spaced knot locations, now between <code>$\phi_1 \in [-110, 30]^\circ$</code>. Because the density of the stream varies on scales of just a few degrees, we use many more knots to represent the stream density.</li>
<li>To represent the 2D density distribution of the stream, we use a Gaussian in <code>$\phi_2$</code> where the mean and standard deviation of the Gaussian are set by spline functions of <code>$\phi_1$</code>. We use the same knot locations for both the mean and standard deviation.</li>
</ul>
<p>Here we also adopt a &ldquo;smoothness&rdquo; prior on the spline values: We assume that the prior on a given <code>$m$</code> spline value is Gaussian with a mean set by the value of the <code>$m-1$</code> knot and fixed standard deviations (defined below). For example, for the stream track (or mean <code>$\phi_2$</code> location <code>$\mu_{\phi_2}$</code>), the prior on the <code>$m$</code>-th mean value is</p>
<div>$$
p(\mu_{\phi_2}^{(m)}) = \mathcal{N}(\mu_{\phi_2}^{(m)} \,|\, \mu_{\phi_2}^{(m-1)}, 0.5^\circ)
$$</div>
<p>This density model is a <em>mixture model</em> in that we have two main components of the model: the stream density and the background (bkg) stellar density. What this means in math is that the full density function <code>$n(\phi_1, \phi_2)$</code> can be expressed as the sum of the two components</p>
<div>$$
n(\phi_1, \phi_2) = n_{\rm stream}(\phi_1, \phi_2) + n_{\rm bkg}(\phi_1, \phi_2)
$$</div>
<p>For numerical stability, we typically work in the log-density instead of the density. Here, that means:</p>
<div>$$
\ln n(\phi_1, \phi_2) = \ln\left[n_{\rm stream}(\phi_1, \phi_2) + n_{\rm bkg}(\phi_1, \phi_2)\right]
$$</div>
<p>But because of the sum, you might think we are stuck adding (potentially) large numbers before taking the log. Luckily, there is a trick for handling cases like this that appears in many different statistics and data science applications known as <a href="https://gregorygundersen.com/blog/2020/02/09/log-sum-exp/">&ldquo;logsumexp&rdquo;</a>, which you will see me use below when combining the individual densities.</p>
<p>As a final point, as was the case with our 1D spline model from Example 1, the integral over the full 2D density function (including the background model and stream model components) is not easily expressible in closed form, but we can use the same numerical integration trick we used above for this model.</p>
<p>The model is more complex than the 1D models, but I will describe each element of the model below using comments:</p>
<pre><code class="language-python">class StreamModel(Model):
    # The phi_1 locations of the knots used for representing the background density:
    bkg_knots = jnp.linspace(-120, 40, 7)

    # The phi_1 locations of the knots used for representing the density along the stream,
    # and for representing the mean and standard deviation of the stream density in the
    # phi_2 direction:
    ln_n0_knots = jnp.linspace(-110, 30, 31)
    phi2_knots = jnp.linspace(-110, 30, 17)

    param_names = {
        &quot;ln_n0&quot;: len(ln_n0_knots),  # The value of the stream density at the knots
        &quot;mean_phi2&quot;: len(phi2_knots),  # The mean phi_2 location of the stream
        &quot;ln_std_phi2&quot;: len(phi2_knots),  # The stddev in phi_2 of the stream
        &quot;ln_n0_bkg&quot;: len(bkg_knots),  # The value of the background density
    }

    # Here we pre-define the grids we will use to perform the numerical integration of
    # the density over our data window phi_1 in (-100, 20) and phi_2 in (-7, 5).
    # A quick note that because I use Simpson's rule for integration, we have to choose
    # a fixed grid to perform the integral on. I had initially chosen a step size of
    # 0.2º but ran into many issues with the optimizer not being able to find a
    # successful solution. I increased the resolution of the integration grid and it
    # seems to work for me, but a caveat here is that there will be some sensitivity to
    # the choice of integration grid. We could use an adaptive method, but I didn't find
    # a good log implementation like we have here for Simpson's rule.
    integ_grid_phi1_1d = jnp.arange(-100, 20 + 1e-3, 0.1)
    integ_grid_phi2_1d = jnp.arange(-7, 5 + 1e-3, 0.1)
    integ_grid_phi1, integ_grid_phi2 = jnp.meshgrid(
        integ_grid_phi1_1d, integ_grid_phi2_1d
    )

    @classmethod
    @partial(jax.jit, static_argnums=(0,))
    def ln_density_stream(cls, phi1, phi2, ln_n0, mean_phi2, ln_std_phi2):
        &quot;&quot;&quot;
        This function evaluates the log-density of the stream component of the model
        &quot;&quot;&quot;
        # As in the 1D example above, we construct interpolating splines given the
        # pre-determined knot locations, with values given as input (i.e. parameters)
        ln_n0_spl = InterpolatedUnivariateSpline(cls.ln_n0_knots, ln_n0, k=3)
        mean_phi2_spl = InterpolatedUnivariateSpline(cls.phi2_knots, mean_phi2, k=3)
        ln_std_phi2_spl = InterpolatedUnivariateSpline(cls.phi2_knots, ln_std_phi2, k=3)

        # We evaluate the splines at the locations of the input data phi1, phi2:
        ln_dens = ln_n0_spl(phi1) + ln_normal(
            phi2, mean_phi2_spl(phi1), jnp.exp(2 * ln_std_phi2_spl(phi1))
        )

        return ln_dens

    @classmethod
    @partial(jax.jit, static_argnums=(0,))
    def ln_density_bkg(cls, phi1, phi2, ln_n0_bkg):
        &quot;&quot;&quot;
        This function evaluates the log-density of the background stellar density
        &quot;&quot;&quot;
        ln_n0_spl = InterpolatedUnivariateSpline(cls.bkg_knots, ln_n0_bkg, k=3)
        return ln_n0_spl(phi1)

    @classmethod
    @partial(jax.jit, static_argnums=(0,))
    def ln_density(cls, phi1, phi2, ln_n0, mean_phi2, ln_std_phi2, ln_n0_bkg):
        &quot;&quot;&quot;
        This evaluates the total model density
        &quot;&quot;&quot;
        ln_dens1 = cls.ln_density_stream(phi1, phi2, ln_n0, mean_phi2, ln_std_phi2)
        ln_dens2 = cls.ln_density_bkg(
            phi1,
            phi2,
            ln_n0_bkg,
        )

        # Note: this is the &quot;logsumexp&quot; trick mentioned above:
        ln_dens = jnp.logaddexp(ln_dens1, ln_dens2)
        return ln_dens

    @classmethod
    @partial(jax.jit, static_argnums=(0,))
    def ln_likelihood(cls, pars, data):
        &quot;&quot;&quot;
        Implementation of the log-likelihood for an inhomogeneous Poisson
        process with underlying density (rate) function
        &quot;&quot;&quot;
        ln_dens = cls.ln_density(
            data[&quot;phi1&quot;],
            data[&quot;phi2&quot;],
            pars[&quot;ln_n0&quot;],
            pars[&quot;mean_phi2&quot;],
            pars[&quot;ln_std_phi2&quot;],
            pars[&quot;ln_n0_bkg&quot;],
        )

        # Here is where we perform the log-integral over n(phi1, phi2) using Simpson's
        # rule. We evauate the log-density function on our pre-defined 2D grid, and use
        # the ln_simpson() function defined above twice to compute the integral:
        ln_dens_grid = cls.ln_density(cls.integ_grid_phi1, cls.integ_grid_phi2, **pars)
        ln_V = ln_simpson(
            ln_simpson(ln_dens_grid, cls.integ_grid_phi1_1d), cls.integ_grid_phi2_1d
        )
        return -jnp.exp(ln_V) + ln_dens.sum()

    @classmethod
    @partial(jax.jit, static_argnums=(0,))
    def ln_prior(cls, pars):
        lp = 0.0

        # The loops below implement the &quot;smoothness&quot; priors on the splines that was
        # mentioned above. The standard deviation values were picked arbitrarily to
        # enforce some smoothness, but to not be too aggressive:
        for i in range(1, len(cls.ln_n0_knots)):
            lp += ln_normal(pars[&quot;ln_n0&quot;][i], pars[&quot;ln_n0&quot;][i - 1], 1)

        for i in range(1, len(cls.phi2_knots)):
            lp += ln_normal(pars[&quot;mean_phi2&quot;][i], pars[&quot;mean_phi2&quot;][i - 1], 1)

        for i in range(1, len(cls.phi2_knots)):
            lp += ln_normal(pars[&quot;ln_std_phi2&quot;][i], pars[&quot;ln_std_phi2&quot;][i - 1], 1)

        return lp
</code></pre>
<pre><code class="language-python">StreamModel.integ_grid_phi1.shape, StreamModel.integ_grid_phi2.shape
</code></pre>
<pre><code>((121, 1201), (121, 1201))
</code></pre>
<p>Now that we have our density model class defined, let&rsquo;s start by computing the density on a 2D grid with some randomly chosen parameter values (i.e. spline knot values). To visualize the density, we will use the 2D integration grid we defined above as <code>StreamModel.integ_grid_phi1</code> and <code>StreamModel.integ_grid_phi2</code> for <code>$\phi_1$</code> and <code>$\phi_2$</code> values, respectively:</p>
<pre><code class="language-python">rng = np.random.default_rng(seed=666)

# Random values for the stream splines:
ln_n0 = rng.uniform(-1, 1, size=len(StreamModel.ln_n0_knots))
mean_phi2 = rng.uniform(-3, 2, size=len(StreamModel.phi2_knots))
ln_std_phi2 = rng.uniform(-1, 1, size=len(StreamModel.phi2_knots))
ln_dens = StreamModel.ln_density_stream(
    StreamModel.integ_grid_phi1,
    StreamModel.integ_grid_phi2,
    ln_n0,
    mean_phi2,
    ln_std_phi2,
)

# And the background density:
ln_n0_bkg = rng.uniform(-1, 1, size=len(StreamModel.bkg_knots))
ln_dens_bkg = StreamModel.ln_density_bkg(
    StreamModel.integ_grid_phi1, StreamModel.integ_grid_phi2, ln_n0_bkg
)

fig, axes = plt.subplots(
    2, 1, figsize=(12, 4), sharex=True, sharey=True, constrained_layout=True
)
axes[0].pcolormesh(
    StreamModel.integ_grid_phi1, StreamModel.integ_grid_phi2, np.exp(ln_dens)
)
axes[0].set_title(&quot;stream component&quot;)
axes[1].pcolormesh(
    StreamModel.integ_grid_phi1, StreamModel.integ_grid_phi2, np.exp(ln_dens_bkg)
)
axes[1].set_title(&quot;background component&quot;)

for ax in axes:
    ax.set_ylabel(r&quot;$\phi_2$ [deg]&quot;)
axes[1].set_xlabel(r&quot;$\phi_1$ [deg]&quot;)
</code></pre>
<pre><code>Text(0.5, 0, '$\\phi_1$ [deg]')
</code></pre>
<p><img src="output_63_1.png" alt="png"></p>
<h2 id="initializing-the-density-model-parameters">Initializing the density model parameters</h2>
<p>In many real-world optimization problems, especially those with many parameters like we have here, a good initialization is often important for success (or at least speed) of the optimizer. We could try initializing the stream model and background with random settings of the parameter (as we visualized above), but it&rsquo;s usually worth spending a bit of time estimating better initial guesses for your parameters.</p>
<p>We will therefore spend a few cells below manipulating the data to estimate the rough on-sky track and density of the stream, and the density of the stellar background.</p>
<pre><code class="language-python">from scipy.ndimage import gaussian_filter1d
</code></pre>
<p>There are many ways we could do this, but in the cell below I bin the data coarsely in <code>$\phi_1$</code> and fine in <code>$\phi_2$</code>, smooth the data, and find the location of the peak in <code>$\phi_2$</code> in the coarse <code>$\phi_1$</code> bins. I then convert the number counts to density so we can extract the rough track of the stream in <code>$\phi_1, \phi_2$</code> along with a density estimate at each of these locations.</p>
<pre><code class="language-python">H, xe, ye = np.histogram2d(
    gd1_tbl[&quot;gd1_phi1&quot;],
    gd1_tbl[&quot;gd1_phi2&quot;],
    bins=(np.linspace(-90, 20 + 1e-3, 11), np.arange(-7, 5 + 1e-3, 0.2)),
)
xc = 0.5 * (xe[:-1] + xe[1:])
yc = 0.5 * (ye[:-1] + ye[1:])

H = gaussian_filter1d(H, sigma=1)
H -= np.mean(H[:, (yc &lt; -5) | (yc &gt; 3)])

H /= (xe[1] - xe[0]) / 12
H_density = H.copy()

peak_idx = H.argmax(axis=1)
H /= H[np.arange(H.shape[0]), peak_idx][:, None]
H_ln_density = np.log(H_density[np.arange(H.shape[0]), peak_idx])


fig, axes = plt.subplots(2, 1, figsize=(8, 6), sharex=True, constrained_layout=True)
cs = axes[0].pcolormesh(xe, ye, H.T, vmin=0, vmax=1, cmap=&quot;Greys&quot;)
axes[0].plot(xc, yc[peak_idx], color=&quot;tab:red&quot;)
axes[0].set_ylabel(r&quot;$\phi_2$&quot;)
axes[1].plot(xc, H_ln_density)
axes[1].set_ylabel(r&quot;log-density&quot;)
axes[1].set_xlabel(r&quot;$\phi_1$&quot;)
</code></pre>
<pre><code>Text(0.5, 0, '$\\phi_1$')
</code></pre>
<p><img src="output_67_1.png" alt="png"></p>
<p>We now have to interpolate these estimates to the location of our spline knots to set the initial parameters of our stream model:</p>
<pre><code class="language-python">init_ln_n0 = sci.InterpolatedUnivariateSpline(xc, H_ln_density)(StreamModel.ln_n0_knots)

init_mean_phi2 = sci.InterpolatedUnivariateSpline(xc, yc[peak_idx])(
    StreamModel.phi2_knots
)
</code></pre>
<p>Next we will handle the stellar background. Here, we select stars above and below the stream (in <code>$\phi_2$</code>), estimate the 1D density of the background using a histogram, and smooth the estimates.</p>
<pre><code class="language-python">_mask = (gd1_tbl[&quot;gd1_phi2&quot;] &gt; 3) | (gd1_tbl[&quot;gd1_phi2&quot;] &lt; -5)
H, xe = np.histogram(gd1_tbl[&quot;gd1_phi1&quot;][_mask], bins=np.linspace(-90, 20 + 1e-3, 15))
xc = 0.5 * (xe[:-1] + xe[1:])

dx = xe[1] - xe[0]
H = np.log(gaussian_filter1d(H, sigma=2) / dx / 4)

fig, ax = plt.subplots(figsize=(8, 4), constrained_layout=True)
ax.plot(xc, H)
ax.set_ylabel(r&quot;log-density&quot;)
ax.set_xlabel(r&quot;$\phi_1$&quot;)
</code></pre>
<pre><code>Text(0.5, 0, '$\\phi_1$')
</code></pre>
<p><img src="output_71_1.png" alt="png"></p>
<p>We again have to interpolate these values to the location of our model spline knots:</p>
<pre><code class="language-python">init_ln_n0_bkg = sci.InterpolatedUnivariateSpline(xc, H)(StreamModel.bkg_knots)
</code></pre>
<p>Now we can package up our initial parameter estimates and try evaluating the <code>StreamModel.ln_density()</code> with this initial guess to see how well we did at estimating the properties of the stream.</p>
<pre><code class="language-python">init_pars = {
    &quot;ln_n0&quot;: init_ln_n0,
    &quot;mean_phi2&quot;: init_mean_phi2,
    &quot;ln_std_phi2&quot;: np.full_like(init_mean_phi2, -1),
    &quot;ln_n0_bkg&quot;: init_ln_n0_bkg,
}
ln_dens_init = StreamModel.ln_density(
    StreamModel.integ_grid_phi1, StreamModel.integ_grid_phi2, **init_pars
)
</code></pre>
<p>We plot the initial guess of the full density distribution and over-plot the positions of the stars in our sample to see how well we did at setting initial guesses:</p>
<pre><code class="language-python">fig, ax = plt.subplots(figsize=(12, 3), constrained_layout=True)

ax.plot(
    gd1_tbl[&quot;gd1_phi1&quot;],
    gd1_tbl[&quot;gd1_phi2&quot;],
    marker=&quot;o&quot;,
    markeredgewidth=0,
    markersize=3.0,
    ls=&quot;none&quot;,
    alpha=0.25,
)
ax.pcolormesh(
    StreamModel.integ_grid_phi1,
    StreamModel.integ_grid_phi2,
    np.exp(ln_dens_init),
    cmap=&quot;Blues&quot;,
)
ax.set_xlim(-100, 20)
ax.set_ylim(-7, 5)

ax.set_xlabel(r&quot;$\phi_1$&quot;)
ax.set_ylabel(r&quot;$\phi_2$&quot;)
</code></pre>
<pre><code>Text(0, 0.5, '$\\phi_2$')
</code></pre>
<p><img src="output_77_1.png" alt="png"></p>
<p>That already looks pretty good, but clearly there are places where we hope the optimizer will tune the model parameters to align the track and width of the stream to the data we have. Let&rsquo;s get set up to run the optimizer from these initial parameter estimates:</p>
<pre><code class="language-python">data = {
    &quot;phi1&quot;: gd1_tbl[&quot;gd1_phi1&quot;].astype(np.float64),
    &quot;phi2&quot;: gd1_tbl[&quot;gd1_phi2&quot;].astype(np.float64),
}
init_p = StreamModel.pack_pars(init_pars)
</code></pre>
<p>This is not necessary, but I always like to evaluate the objective function I want to optimize at the initial parameter values to make sure there are no nan or inf values that will cause the optimizer to immediately fail:</p>
<pre><code class="language-python">StreamModel.objective(init_p, N=len(data[&quot;phi1&quot;]), data=data)
</code></pre>
<pre><code>DeviceArray(-0.05543877, dtype=float64)
</code></pre>
<p>Good, that looks fine! Let&rsquo;s fire up the optimizer. We will again use the L-BFGS-B method:</p>
<pre><code class="language-python">res = sco.minimize(
    jax.value_and_grad(StreamModel.objective),
    StreamModel.pack_pars(init_pars),
    args=(len(data[&quot;phi1&quot;]), data),
    jac=True,
    method=&quot;l-bfgs-b&quot;,
    options=dict(maxiter=100_000, maxls=1000),
)
res
</code></pre>
<pre><code>      fun: -0.4172804414762403
 hess_inv: &lt;72x72 LbfgsInvHessProduct with dtype=float64&gt;
      jac: array([-7.71418475e-07,  1.65857911e-07,  1.99453381e-07, -2.05370143e-06,
       -1.70964779e-06, -4.62670967e-06,  1.68103189e-06,  2.09021076e-06,
       -1.10096842e-06,  2.27286148e-06, -1.52102203e-06, -1.37678490e-06,
       -2.28720309e-06, -2.26237554e-06, -1.30669594e-07, -3.37215730e-06,
       -1.02103330e-06,  8.87957954e-07,  2.43060947e-06,  4.48877098e-06,
        2.33454660e-06,  1.11753802e-06,  9.77205135e-07, -6.95522218e-07,
        1.15479706e-06, -1.69470906e-06,  1.78318820e-06, -1.94111769e-07,
       -5.52840315e-07, -7.36288750e-07, -8.92639157e-07,  1.55186650e-06,
       -1.59999460e-06, -3.26062519e-07,  3.79777447e-07,  3.28915248e-06,
       -7.19254555e-07, -3.63050574e-06, -1.34650105e-05, -1.33010540e-06,
        3.07614063e-05,  1.18970084e-05,  1.65802843e-05,  4.66520356e-06,
       -1.04483424e-06,  5.07504938e-07, -2.62358590e-06,  1.97680049e-07,
        1.39519635e-06, -5.60004049e-07,  2.91998158e-06, -3.85801945e-07,
        6.49247930e-07,  1.38578698e-06,  3.24259772e-06, -3.13469064e-06,
        1.89760659e-06, -3.11670312e-06,  6.85084618e-07, -8.07002305e-06,
       -2.91758878e-06,  3.64299264e-06, -2.47082774e-07,  1.81615140e-06,
        6.16494751e-07, -2.46474178e-07,  3.60654040e-06, -9.61968004e-08,
        3.94092601e-06,  3.81585532e-07, -8.09581201e-07,  1.17461144e-06])
  message: 'CONVERGENCE: REL_REDUCTION_OF_F_&lt;=_FACTR*EPSMCH'
     nfev: 470
      nit: 439
     njev: 470
   status: 0
  success: True
        x: array([-1.29724792, -1.29012651, -1.32220017, -1.01112565, -0.4372693 ,
        0.58312065,  1.56485491,  1.84623316,  1.86679529,  1.75244974,
        1.79167502,  2.39936208,  2.96517374,  3.28641774,  3.13259102,
        2.63325926,  2.72104495,  2.89475705,  2.89169773,  1.78894259,
        2.6488234 ,  3.05108255,  2.03688664,  2.74065293,  2.74767283,
        1.03251669,  0.73350755, -0.19425672, -0.36811195, -0.38745796,
       -0.38802526, -4.32570901, -4.29026727, -4.60164536, -2.65188131,
       -1.68654545, -1.0399299 , -0.49073281,  0.01935266,  0.15563387,
        0.07482995,  0.0315922 , -0.10760813, -0.75555268, -1.5350805 ,
       -1.82638106, -1.86999619, -1.86537359, -1.83413212, -1.86183605,
       -1.61951924, -0.98992293, -0.53122539, -0.83928341, -1.24429333,
       -1.24835943, -1.08013281, -1.86097141, -1.66590174, -1.82412536,
       -1.64303541, -1.32500325, -1.95722173, -1.62772084, -1.67305163,
       -2.76395382, -0.72947985, -0.56382768,  0.23704327,  0.85720292,
        0.13801779,  1.7967009 ])
</code></pre>
<p>It looks like that succeeded! Let&rsquo;s look at the optimized parameters:</p>
<pre><code class="language-python">opt_pars = StreamModel.unpack_pars(res.x)
opt_pars
</code></pre>
<pre><code>{'ln_n0': DeviceArray([-1.29724792, -1.29012651, -1.32220017, -1.01112565,
              -0.4372693 ,  0.58312065,  1.56485491,  1.84623316,
               1.86679529,  1.75244974,  1.79167502,  2.39936208,
               2.96517374,  3.28641774,  3.13259102,  2.63325926,
               2.72104495,  2.89475705,  2.89169773,  1.78894259,
               2.6488234 ,  3.05108255,  2.03688664,  2.74065293,
               2.74767283,  1.03251669,  0.73350755, -0.19425672,
              -0.36811195, -0.38745796, -0.38802526], dtype=float64),
 'ln_n0_bkg': DeviceArray([-2.76395382, -0.72947985, -0.56382768,  0.23704327,
               0.85720292,  0.13801779,  1.7967009 ], dtype=float64),
 'ln_std_phi2': DeviceArray([-1.83413212, -1.86183605, -1.61951924, -0.98992293,
              -0.53122539, -0.83928341, -1.24429333, -1.24835943,
              -1.08013281, -1.86097141, -1.66590174, -1.82412536,
              -1.64303541, -1.32500325, -1.95722173, -1.62772084,
              -1.67305163], dtype=float64),
 'mean_phi2': DeviceArray([-4.32570901, -4.29026727, -4.60164536, -2.65188131,
              -1.68654545, -1.0399299 , -0.49073281,  0.01935266,
               0.15563387,  0.07482995,  0.0315922 , -0.10760813,
              -0.75555268, -1.5350805 , -1.82638106, -1.86999619,
              -1.86537359], dtype=float64)}
</code></pre>
<p>Again, it looks like there are no NaN or inf values, so that&rsquo;s good. Let&rsquo;s now compare the optimized parameters to our initial guesses:</p>
<pre><code class="language-python">fig, axes = plt.subplots(2, 2, figsize=(10, 6), sharex=True, constrained_layout=True)
for ax, knots, name in zip(
    axes.flat,
    [
        StreamModel.ln_n0_knots,
        StreamModel.phi2_knots,
        StreamModel.phi2_knots,
        StreamModel.bkg_knots,
    ],
    [&quot;ln_n0&quot;, &quot;mean_phi2&quot;, &quot;ln_std_phi2&quot;, &quot;ln_n0_bkg&quot;],
):
    ax.plot(knots, init_pars[name], label=&quot;initial&quot;, color=&quot;#aaaaaa&quot;, linewidth=1)
    ax.plot(knots, opt_pars[name], label=&quot;optimized&quot;, color=&quot;k&quot;)
    ax.set_title(name)

for ax in axes[-1]:
    ax.set_xlabel(r&quot;$\phi_1$&quot;)

ax.legend(loc=&quot;best&quot;, fontsize=14)
</code></pre>
<pre><code>&lt;matplotlib.legend.Legend at 0x7ff4f5b089d0&gt;
</code></pre>
<p><img src="output_87_1.png" alt="png"></p>
<p>We can also look at the 2D density computed from our optimized parameters and visually compare to the data:</p>
<pre><code class="language-python">ln_dens_opt = StreamModel.ln_density(
    StreamModel.integ_grid_phi1, StreamModel.integ_grid_phi2, **opt_pars
)
</code></pre>
<pre><code class="language-python">fig, axes = plt.subplots(
    3, 1, figsize=(12, 8), sharex=True, sharey=True, constrained_layout=True
)

for ax in [axes[0], axes[2]]:
    ax.plot(
        gd1_tbl[&quot;gd1_phi1&quot;],
        gd1_tbl[&quot;gd1_phi2&quot;],
        marker=&quot;o&quot;,
        markeredgewidth=0,
        markersize=3.0,
        ls=&quot;none&quot;,
        alpha=0.25,
    )

ax = axes[1]
ax.pcolormesh(
    StreamModel.integ_grid_phi1,
    StreamModel.integ_grid_phi2,
    np.exp(ln_dens_opt),
    cmap=&quot;Blues&quot;,
)

ax = axes[2]
ax.pcolormesh(
    StreamModel.integ_grid_phi1,
    StreamModel.integ_grid_phi2,
    np.exp(ln_dens_opt),
    cmap=&quot;Blues&quot;,
)

ax.set_xlim(-100, 20)
ax.set_ylim(-7, 5)

axes[-1].set_xlabel(r&quot;$\phi_1$&quot;)
for ax in axes:
    ax.set_ylabel(r&quot;$\phi_2$&quot;)
</code></pre>
<p><img src="output_90_0.png" alt="png"></p>
<p>This looks like a pretty good representation of the stream density and track, so I would call this a success! With the optimized parameters in hand, we could then run a sampler (like the HMC/NUTS sampler we used above) to generate posterior samples over our parameters and assess uncertainty in the model, or compute membership probabilities of belonging to the stream for the stars in this field. In a real application, we may also want to assess our choices by trying a few different settings for the number of spline knots for the different components of the model.</p>
<h1 id="recap">Recap</h1>
<p>This tutorial demonstrates how to use flexible, spline-based models in density functions with <a href="https://jax.readthedocs.io/">JAX</a>, which provides automatic calculation of gradients through our models and enables fast optimization and MCMC sampling methods even in cases like the above where the number of parameters is large.</p>
<p>If you have any comments or questions about this tutorial, please <a href="https://github.com/adrn-blog/post--flexible-density-model-jax/issues">open an issue on the GitHub repository for this post</a>. Thanks for reading!</p>

  </div>
</section>


<footer class="text-center footer">
  <hr />
  
  <h6 class="text-center copyright">© 2015-2022 Adrian Price-Whelan</h6>
  
  <h6 class="text-center extra-footer">Reach me at <a href="mailto:adrianmpw@gmail.com">adrianmpw@gmail.com</a></h6>
  
  
</footer>

</div>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-11936482-16', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="../../js/main.js"></script>
<script src="../../js/custom.js"></script>



  
  <script src="https://unpkg.com/prismjs@1.20.0/components/prism-core.min.js"></script>

  
  <script src="https://unpkg.com/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js"
    data-autoloader-path="https://unpkg.com/prismjs@1.20.0/components/"></script>




</body>
</html>



<!DOCTYPE html>
<html lang="en-us">
<head>

<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="description" content="Simple minimalist theme">
<meta name="keywords" content="minimalist,blog,goa,hugo,developer">

<title>
  apw - Flexible (stellar spatial) density models with Jax 
</title>

<meta name="generator" content="Hugo 0.89.0" />


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">


<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;1,300&family=Merriweather:wght@100;200;300;400;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css" integrity="sha384-DyZ88mC6Up2uqS4h/KRgHuoeGwBcD4Ng9SiP4dIRy0EXTlnuz47vAwmeGwVChigm" crossorigin="anonymous"/>
<link rel="stylesheet" href="https://adrian.pw/css/main.css">
<link rel="stylesheet" href="https://adrian.pw/css/custom.css">





<link rel="icon" type="image/png" href="../../img/favicon.ico" />


<link rel="manifest" href="../../manifest.json">

<meta name="theme-color" content="#ffffff">

</head>
<body lang="en-us">
<div class="container">


<header class="text-left content-header">
  <h1 class="author">Adrian Price-Whelan</h1>
  <h3 class="title">Flexible (stellar spatial) density models with Jax</h1>
</header>
<section id="category-pane" class="meta">
  
  <div class="col-md-12">
    <h6 class="text-left meta">
        PUBLISHED ON AUG 25, 2022 
      
    </h6>
  </div>
  
</section>
<section id="content-pane" class="">
  <div class="col-md-12 text-justify content">
    <p>A problem I have run into frequently in astronomical data analysis is the need to infer parameters of a density model where some aspects of the model are allowed to be flexible and other components are held more rigid. In these contexts, we are also sometimes interested in learning a flexible representation for the density of sources itself. This post demonstrates how to implement models with flexibility controlled by spline interpolation of function values in <a href="https://jax.readthedocs.io/en/latest/">JAX</a>.</p>
<p>One example of the need for flexibility in density modeling is the classic Galactic astronomy problem of measuring the vertical stellar density profile (and midplane density) of the Galactic disk: In this problem, we start with observations of stellar positions (<code>$x, y, z$</code>) (probably observed under some selection function) and we want to infer the midplane density value and a model for the density profile away from the midplane. Historically, simple, parametric density profiles have been used (e.g., <a href="https://ui.adsabs.harvard.edu/abs/2017MNRAS.470.1360B/abstract">Bovy et al. 2017</a>), but we now know that there are significant asymmetries in the density of stars (e.g., <a href="https://ui.adsabs.harvard.edu/abs/2019MNRAS.482.1417B/abstract">Bennett et al. 2019</a>), and so we might now want to fit a parametric density profile plus a model component to handle this asymmetry.</p>
<p>Another problem where the need to fit models with parametric and flexible components arises is in modeling the phase-space density of stellar streams (e.g., <a href="https://ui.adsabs.harvard.edu/abs/2019MNRAS.485.4726K/abstract">Koposov et al. 2019</a>, <a href="https://ui.adsabs.harvard.edu/abs/2022ApJ...925..118T/abstract">Tavangar et al. 2022</a>). In the case of stellar streams, we generally want to simultaneously fit the &ldquo;track&rdquo; or ridgeline of the stream in position and velocity components, the width of the stream, the density along the stream, and a flexible model for the background stellar density in these components.</p>
<p>There are many possible options for adding flexibility to models (see: Machine Learning). One particularly useful tool that is used heavily in time series analysis are <a href="https://en.wikipedia.org/wiki/Gaussian_process">Gaussian processes</a> (GPs). GPs allow adding controlled flexibility in probabilistic models (i.e. weakly parametric, through specification of a kernel function) and have gained popularity in astronomy recently thanks to advances in computational efficiency in computing GP likelihoods (e.g., <a href="https://github.com/exoplanet-dev/celerite2">celerite</a> or <a href="https://github.com/dfm/tinygp">tinygp</a>). I won&rsquo;t go over GPs in this post, but there are many resources available online and on GitHub that give great introductions to GPs (e.g., <a href="https://speakerdeck.com/dfm/an-astronomers-introduction-to-gaussian-processes-v2">Dan Foreman-Mackey&rsquo;s slides</a> or <a href="https://github.com/LSSTC-DSFP/LSSTC-DSFP-Sessions/blob/main/Sessions/Session13/Day2/answers/01-Introduction-to-GPs.ipynb">Rodrigo Luger&rsquo;s tutorial</a>).</p>
<p>In this post, we will use another frequently-used tool for specifying flexible models: <a href="https://en.wikipedia.org/wiki/Spline_(mathematics)">cubic splines</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Some global imports we will need throughout this post:</span>
<span style="color:#f92672">import</span> astropy.units <span style="color:#66d9ef">as</span> u
<span style="color:#f92672">import</span> matplotlib <span style="color:#66d9ef">as</span> mpl
<span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#66d9ef">as</span> plt

<span style="color:#75715e"># This ensures that JAX runs with 64-bit float precision by default:</span>
<span style="color:#f92672">from</span> jax.config <span style="color:#f92672">import</span> config

config<span style="color:#f92672">.</span>update(<span style="color:#e6db74">&#34;jax_enable_x64&#34;</span>, <span style="color:#66d9ef">True</span>)
<span style="color:#f92672">import</span> jax
<span style="color:#f92672">import</span> jax.numpy <span style="color:#66d9ef">as</span> jnp

<span style="color:#f92672">%</span>matplotlib inline
<span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</code></pre></div><h1 id="spline-models">Spline models</h1>
<p>A spline function is fully determined by the degree of the polynomial used, the location of <code>$M$</code> &ldquo;knots&rdquo; <code>$x_m$</code>, and the function value at the knots <code>$f_m$</code>. A common choice for the polynomial degree is 3, or cubic splines.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> scipy.interpolate <span style="color:#66d9ef">as</span> sci
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">rng <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>default_rng(seed<span style="color:#f92672">=</span><span style="color:#ae81ff">42</span>)

M <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>
x_m <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">10</span>, M)
f_m <span style="color:#f92672">=</span> rng<span style="color:#f92672">.</span>uniform(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, M)
spl <span style="color:#f92672">=</span> sci<span style="color:#f92672">.</span>InterpolatedUnivariateSpline(x_m, f_m, k<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>)  <span style="color:#75715e"># k = the polynomial degree</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">plt<span style="color:#f92672">.</span>scatter(x_m, f_m)

grid <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">1024</span>)
plt<span style="color:#f92672">.</span>plot(grid, spl(grid), marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>, linestyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;-&#34;</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;tab:blue&#34;</span>, zorder<span style="color:#f92672">=-</span><span style="color:#ae81ff">10</span>)

plt<span style="color:#f92672">.</span>annotate(
    <span style="color:#e6db74">&#34;knots&#34;</span>,
    xy<span style="color:#f92672">=</span>(x_m[<span style="color:#ae81ff">0</span>], f_m[<span style="color:#ae81ff">0</span>]),
    xytext<span style="color:#f92672">=</span>(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>),
    arrowprops<span style="color:#f92672">=</span>dict(color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;#666&#34;</span>, shrinkB<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>, arrowstyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;-&gt;&#34;</span>),
    ha<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;center&#34;</span>,
)
<span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>):
    plt<span style="color:#f92672">.</span>annotate(
        <span style="color:#e6db74">&#34;     &#34;</span>,
        xy<span style="color:#f92672">=</span>(x_m[m], f_m[m]),
        xytext<span style="color:#f92672">=</span>(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>),
        arrowprops<span style="color:#f92672">=</span>dict(color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;#666&#34;</span>, shrinkB<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>, arrowstyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;-&gt;&#34;</span>),
        ha<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;center&#34;</span>,
    )

plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;$x$&#34;</span>)
plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;$f$&#34;</span>)
</code></pre></div><pre><code>Text(0, 0.5, '$f$')



WARNING:matplotlib.font_manager:findfont: Font family ['serif'] not found. Falling back to DejaVu Sans.
WARNING:matplotlib.font_manager:findfont: Generic family 'serif' not found because none of the following families were found: Old Standard TT
WARNING:matplotlib.font_manager:findfont: Font family ['serif'] not found. Falling back to DejaVu Sans.
WARNING:matplotlib.font_manager:findfont: Generic family 'serif' not found because none of the following families were found: Old Standard TT
</code></pre>
<p><img src="output_5_2.png" alt="png"></p>
<p>The task of finding a spline representation of a function given samples or points is sometimes called &ldquo;spline regression.&rdquo; The problem is straightforward if we pick and fix locations for the knots of the spline function we want to fit and then add into our model the values of the function at the locations of the knots. This type of model has the advantage that the (spatial) scale of flexibility or &ldquo;degrees of freedom&rdquo; is controllable by setting the number of knots. However, unlike in GPs where kernel functions can be used to parametrize the amplitude or spatial scales of your problem, these things are not explicitly controlled in a spline model. One other disadvantage of a spline model is that the number of parameters in your model grows as you increase the number of knots (i.e. the degrees of freedom) of the model &ndash; this can make spline models intractable in some simple optimization routines (e.g., using <code>scipy.minimize</code> without gradient information) or in some Markov Chain Monte Carlo (MCMC) methods that do not use gradient information (e.g., Metropolis-Hastings or <a href="https://emcee.readthedocs.io/en/stable/"><code>emcee</code></a>).</p>
<p>Fortunately, it is possible to use spline models with <a href="https://jax.readthedocs.io/">JAX</a>, which automatically gives us access to functional gradients and therefore opens up the possibility of using optimization and sampling methods that perform well with large numbers of parameters. Below are two examples that demonstrate how to implement spline components in density models using JAX, to optimize the parameters of the models with <a href="https://jaxopt.github.io/"><code>jaxopt</code></a>, and to generate posterior samples using Hamiltonian Monte Carlo with <a href="https://blackjax-devs.github.io/blackjax/"><code>blackjax</code></a>.</p>
<h1 id="example-fitting-a-1d-density-profile-with-splines">Example: Fitting a 1D density profile with splines</h1>
<p>As a first demonstration of the idea, we are going to use simulated data to mock up a simpler version of the vertical density problem mentioned above. We will generate simulated data from a Gaussian, and then show how to fit the density distribution by modeling the points as an <a href="https://en.wikipedia.org/wiki/Poisson_point_process#Inhomogeneous_Poisson_point_process">inhomogeneous Poisson process</a> with either (1) a Gaussian or (2) a cubic spline density function. In either case, given a density function <code>$n(z)$</code> (Gaussian or spline), our likelihood and log-likelihood are given by the Poisson process likelihood, given all <code>$N$</code> of our <code>$z_n$</code> data points:</p>
<div>$$
\begin{align}
p(\left\{z_n\right\}_N \,|\, n(z)) &=
    \exp{\left[-\int {\rm d}z \, n(z)\right]} \, \prod_n^N n(z_n)
\end{align}
$$</div>
<h2 id="case-1-gaussian-model">Case 1: Gaussian model</h2>
<p>For our first demo, we will use a Gaussian to fit the data (which were generated by a Gaussian, so this is truly a toy example). In this case:</p>
<div>$$
\begin{align}
n(z \,|\, N_0, \mu, \sigma) &= N_0 \, \mathcal{N}(z \,|\, \mu, \sigma)\\
\mathcal{N}(x \,|\, \mu, \sigma) &= \frac{1}{\sqrt{2\pi\,\sigma^2}} \, e^{-\,\frac{(x - \mu)^2}{2\,\sigma^2}}\\
\end{align}
$$</div>
where `$\mathcal{N}$` represents the normal distribution, `$N_0$` is the total number of sources, and the mean `$\mu$` and standard deviation `$\sigma$` are the usual Gaussian parameters. 
<p>The integral that appears in the first term of the Poisson process likelihood above is therefore just the total number <code>$N_0$</code>, as the integral over the normal distribution <code>$\mathcal{N}$</code> is 1:</p>
<div>$$
\begin{align}
    p(\left\{z_n\right\}_N \,|\, N_0, \mu, \sigma) &= \exp{\left[-N_0 \, \int {\rm d}z \, \mathcal{N}(z)\right]}  \, \prod_n^N n(z_n)\\
    &= e^{-n_0}  \, N_0^N \, \prod_n^N \mathcal{N}(z_n \,|\, \mu, \sigma)\\
\end{align}
$$</div>
<p>The log-likelihood is therefore (where <code>$N$</code> is the number of data points, and <code>$N_0$</code> is a parameter):</p>
<div>$$
\begin{align}
\ln p(\left\{z_n\right\}_N \,|\, n_0, \mu, \sigma) &=
    -N_0 + N\,\ln N_0 + \sum_n^N \ln \mathcal{N}(z_n \,|\, \mu, \sigma)
\end{align}
$$</div>
<p>To start with, we will generate some random, normal distributed points with arbitrarily chosen mean and variance:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">rng <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>default_rng(seed<span style="color:#f92672">=</span><span style="color:#ae81ff">42</span>)

N <span style="color:#f92672">=</span> <span style="color:#ae81ff">100_000</span>
z <span style="color:#f92672">=</span> rng<span style="color:#f92672">.</span>normal(<span style="color:#ae81ff">0.03</span>, <span style="color:#ae81ff">0.31</span>, size<span style="color:#f92672">=</span>N)

<span style="color:#75715e"># Pack the data into a dictionary so later we can store other metadata. For</span>
<span style="color:#75715e"># reasons that will be clear later, we also store the number of data points</span>
<span style="color:#75715e"># in this dictionary data structure:</span>
data <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;N&#34;</span>: N, <span style="color:#e6db74">&#34;z&#34;</span>: z}
</code></pre></div><p>Let&rsquo;s start by making a histogram of the &ldquo;data&rdquo; to visualize it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">z_bins <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">128</span>)
plt<span style="color:#f92672">.</span>hist(data[<span style="color:#e6db74">&#34;z&#34;</span>], bins<span style="color:#f92672">=</span>z_bins)
plt<span style="color:#f92672">.</span>yscale(<span style="color:#e6db74">&#34;log&#34;</span>)
plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;$z$&#34;</span>)
plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;number of sources&#34;</span>);
</code></pre></div><p><img src="output_11_0.png" alt="png"></p>
<p>To visualize an estimate of the density function, we can use the <code>numpy.histogram</code> function instead to compute the number counts per bin and divide by the size of each bin:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">H, xe <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>histogram(data[<span style="color:#e6db74">&#34;z&#34;</span>], bins<span style="color:#f92672">=</span>z_bins)
xc <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">*</span> (xe[:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> xe[<span style="color:#ae81ff">1</span>:])
dens <span style="color:#f92672">=</span> H <span style="color:#f92672">/</span> (xe[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> xe[<span style="color:#ae81ff">0</span>])

plt<span style="color:#f92672">.</span>plot(xc, dens, drawstyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;steps-mid&#34;</span>, marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)
plt<span style="color:#f92672">.</span>yscale(<span style="color:#e6db74">&#34;log&#34;</span>)

plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;$z$&#34;</span>)
plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;density $n(z)$&#34;</span>);
</code></pre></div><p><img src="output_13_0.png" alt="png"></p>
<p>In what follows, we are going to be defining several different density models and objective functions for our different density models. But ultimately, with all of these choices (e.g., Gaussian density model vs. cubic spline), we will need to be able to compute the log-likelihood given a choice of parameters. I like to use object-oriented programming (OOP) to structure my code when I am in situations like this because it helps to reduce duplicated code, enables encapsulation and namespacing, and, frankly, because I think the benefits of Python shine when using OOP. However, JAX is really designed to be used within a <a href="https://en.wikipedia.org/wiki/Functional_programming"><em>functional programming</em></a> context because of the way <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">Just-in-time</a> (JIT) compilation works. You can read a bit more about this in the <a href="https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html">JAX Gotchas</a> page, but the bottom line is that all JIT-compiled functions must be <em>pure functions</em> (functions that return the same values given the same input arguments).</p>
<p>There are some advanced ways of implementing more OOP-like code with JAX, but here I&rsquo;m going to (ab)use Python classes as a simple way of creating namespaces for the functions we will need with a light form of inheritance that still obeys the <em>pure function</em> requirement of JAX. These classes don&rsquo;t look like true OOP because we use <code>@classmethod</code>&rsquo;s instead of regular instance methods, but some other OOP ideas still translate. We will start by defining a base <code>Model</code> class that implements some common methods we will need for any of the density models we implement:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># We will need to wrap JAX&#39;s jit function with a partial function call to get</span>
<span style="color:#75715e"># it to work with our classmethod&#39;s below. We will use it to tell JAX to treat</span>
<span style="color:#75715e"># the 0&#39;th input (i.e. the class itself in a classmethod) as a compile-time</span>
<span style="color:#75715e"># constant-valued object:</span>
<span style="color:#f92672">from</span> functools <span style="color:#f92672">import</span> partial


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Model</span>:
    <span style="color:#75715e"># This will store the parameter names and expected sizes of the parameters</span>
    <span style="color:#75715e"># (to allow for array-valued parameters) for the density models we</span>
    <span style="color:#75715e"># implement later on:</span>
    param_names <span style="color:#f92672">=</span> {}

    <span style="color:#a6e22e">@classmethod</span>
    <span style="color:#a6e22e">@partial</span>(jax<span style="color:#f92672">.</span>jit, static_argnums<span style="color:#f92672">=</span>(<span style="color:#ae81ff">0</span>,))
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">unpack_pars</span>(cls, p_arr):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        This function takes a parameter array and unpacks it into a dictionary
</span><span style="color:#e6db74">        with the parameter names as keys.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        p_dict <span style="color:#f92672">=</span> {}
        j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">for</span> name, size <span style="color:#f92672">in</span> cls<span style="color:#f92672">.</span>param_names<span style="color:#f92672">.</span>items():
            p_dict[name] <span style="color:#f92672">=</span> jnp<span style="color:#f92672">.</span>squeeze(p_arr[j : j <span style="color:#f92672">+</span> size])
            j <span style="color:#f92672">+=</span> size
        <span style="color:#66d9ef">return</span> p_dict

    <span style="color:#a6e22e">@classmethod</span>
    <span style="color:#a6e22e">@partial</span>(jax<span style="color:#f92672">.</span>jit, static_argnums<span style="color:#f92672">=</span>(<span style="color:#ae81ff">0</span>,))
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">pack_pars</span>(cls, p_dict):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        This function takes a parameter dictionary and packs it into a JAX array
</span><span style="color:#e6db74">        where the order is set by the parameter name list defined on the class.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        p_arrs <span style="color:#f92672">=</span> []
        <span style="color:#66d9ef">for</span> name <span style="color:#f92672">in</span> cls<span style="color:#f92672">.</span>param_names<span style="color:#f92672">.</span>keys():
            p_arrs<span style="color:#f92672">.</span>append(jnp<span style="color:#f92672">.</span>atleast_1d(p_dict[name]))
        <span style="color:#66d9ef">return</span> jnp<span style="color:#f92672">.</span>concatenate(p_arrs)

    <span style="color:#a6e22e">@classmethod</span>
    <span style="color:#a6e22e">@partial</span>(jax<span style="color:#f92672">.</span>jit, static_argnums<span style="color:#f92672">=</span>(<span style="color:#ae81ff">0</span>,))
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ln_posterior</span>(cls, pars_arr, data, <span style="color:#f92672">*</span>args):
        pars <span style="color:#f92672">=</span> cls<span style="color:#f92672">.</span>unpack_pars(pars_arr)
        <span style="color:#66d9ef">return</span> cls<span style="color:#f92672">.</span>ln_likelihood(pars, data, <span style="color:#f92672">*</span>args) <span style="color:#f92672">+</span> cls<span style="color:#f92672">.</span>ln_prior(pars)

    <span style="color:#a6e22e">@classmethod</span>
    <span style="color:#a6e22e">@partial</span>(jax<span style="color:#f92672">.</span>jit, static_argnums<span style="color:#f92672">=</span>(<span style="color:#ae81ff">0</span>,))
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">objective</span>(cls, pars_arr, N, data, <span style="color:#f92672">*</span>args):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        This function computes an objective function to be *minimized*: In our
</span><span style="color:#e6db74">        case, we will be doing Bayesian statistics, so this is generally the
</span><span style="color:#e6db74">        negative log-posterior-probability value such that if we minimize the
</span><span style="color:#e6db74">        objective function, we obtain the maximum a posteriori (MAP) parameter
</span><span style="color:#e6db74">        values. Here we also normalize the value by the number of data points so
</span><span style="color:#e6db74">        that scipy&#39;s minimizers don&#39;t run into overflow issues with the
</span><span style="color:#e6db74">        gradients.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>cls<span style="color:#f92672">.</span>ln_posterior(pars_arr, data, <span style="color:#f92672">*</span>args) <span style="color:#f92672">/</span> N
</code></pre></div><p>With our base <code>Model</code> class defined, we can now implement a subclass for the first model we are going to fit to our simulated data: a Gaussian! Using the true density model to fit the simulated data we should recover the input parameters that we used to generate the data:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ln_normal</span>(x, mu, var):
    <span style="color:#e6db74">&#34;&#34;&#34;Evaluate the log-normal probability&#34;&#34;&#34;</span>
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0.5</span> <span style="color:#f92672">*</span> (jnp<span style="color:#f92672">.</span>log(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>pi <span style="color:#f92672">*</span> var) <span style="color:#f92672">+</span> (x <span style="color:#f92672">-</span> mu) <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">/</span> var)
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GaussianModel</span>(Model):
    param_names <span style="color:#f92672">=</span> {
        <span style="color:#e6db74">&#34;ln_N0&#34;</span>: <span style="color:#ae81ff">1</span>,  <span style="color:#75715e"># the log number density</span>
        <span style="color:#e6db74">&#34;mean&#34;</span>: <span style="color:#ae81ff">1</span>,  <span style="color:#75715e"># the mean of the Gaussian</span>
        <span style="color:#e6db74">&#34;ln_std&#34;</span>: <span style="color:#ae81ff">1</span>,  <span style="color:#75715e"># the log standard deviation</span>
    }

    <span style="color:#a6e22e">@staticmethod</span>
    <span style="color:#a6e22e">@jax</span><span style="color:#f92672">.</span>jit
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ln_density</span>(x, ln_N0, mean, ln_std):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        This function implements the log-density of our model. Here, this is the
</span><span style="color:#e6db74">        log-Gaussian.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        var <span style="color:#f92672">=</span> jnp<span style="color:#f92672">.</span>exp(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> ln_std)
        <span style="color:#66d9ef">return</span> ln_N0 <span style="color:#f92672">+</span> ln_normal(x, mean, jnp<span style="color:#f92672">.</span>exp(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> ln_std))

    <span style="color:#a6e22e">@classmethod</span>
    <span style="color:#a6e22e">@partial</span>(jax<span style="color:#f92672">.</span>jit, static_argnums<span style="color:#f92672">=</span>(<span style="color:#ae81ff">0</span>,))
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ln_likelihood</span>(cls, pars, data):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        Implementation of the log-likelihood for an inhomogeneous Poisson
</span><span style="color:#e6db74">        process with underlying density (rate) function given by a Gaussian.
</span><span style="color:#e6db74">        Here the integral over our density function is has a simple closed form
</span><span style="color:#e6db74">        solution (see the math above).
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        dens <span style="color:#f92672">=</span> cls<span style="color:#f92672">.</span>ln_density(data[<span style="color:#e6db74">&#34;z&#34;</span>], <span style="color:#f92672">**</span>pars)
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>jnp<span style="color:#f92672">.</span>exp(pars[<span style="color:#e6db74">&#34;ln_N0&#34;</span>]) <span style="color:#f92672">+</span> dens<span style="color:#f92672">.</span>sum()

    <span style="color:#a6e22e">@classmethod</span>
    <span style="color:#a6e22e">@partial</span>(jax<span style="color:#f92672">.</span>jit, static_argnums<span style="color:#f92672">=</span>(<span style="color:#ae81ff">0</span>,))
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ln_prior</span>(cls, pars):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        A very light prior on the parameters. We again use Normal&#39;s for priors,
</span><span style="color:#e6db74">        but for most parameters we use relatively wide (large variance) values
</span><span style="color:#e6db74">        so that the prior does not have much of an influence.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        lp <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>

        <span style="color:#75715e"># A very wide, basically unconstrained Gaussian</span>
        lp <span style="color:#f92672">+=</span> ln_normal(pars[<span style="color:#e6db74">&#34;ln_N0&#34;</span>], <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">100</span>)

        <span style="color:#75715e"># We expect the mean to be close to 0</span>
        lp <span style="color:#f92672">+=</span> ln_normal(pars[<span style="color:#e6db74">&#34;mean&#34;</span>], <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>)

        <span style="color:#75715e"># We expect the standard deviation to be small:</span>
        lp <span style="color:#f92672">+=</span> ln_normal(pars[<span style="color:#e6db74">&#34;ln_std&#34;</span>], <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)

        <span style="color:#66d9ef">return</span> lp
</code></pre></div><p>Let&rsquo;s pick some initial values for our parameters and plot the density function corresponding to our parameter choices:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">plt<span style="color:#f92672">.</span>plot(xc, dens, drawstyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;steps-mid&#34;</span>, marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)

init_pars <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;ln_N0&#34;</span>: np<span style="color:#f92672">.</span>log(N) <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5</span>, <span style="color:#e6db74">&#34;mean&#34;</span>: <span style="color:#ae81ff">1e-1</span>, <span style="color:#e6db74">&#34;ln_std&#34;</span>: np<span style="color:#f92672">.</span>log(<span style="color:#ae81ff">0.3</span>)}
init_p <span style="color:#f92672">=</span> GaussianModel<span style="color:#f92672">.</span>pack_pars(init_pars)

z_grid <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(z_bins<span style="color:#f92672">.</span>min(), z_bins<span style="color:#f92672">.</span>max(), <span style="color:#ae81ff">1024</span>)
plt<span style="color:#f92672">.</span>plot(z_grid, np<span style="color:#f92672">.</span>exp(GaussianModel<span style="color:#f92672">.</span>ln_density(z_grid, <span style="color:#f92672">**</span>init_pars)), marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)

plt<span style="color:#f92672">.</span>yscale(<span style="color:#e6db74">&#34;log&#34;</span>)

plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;$z$&#34;</span>)
plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;density $n(z)$&#34;</span>);
</code></pre></div><pre><code>WARNING:absl:No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)
</code></pre>
<p><img src="output_20_1.png" alt="png"></p>
<p>Those initial parameter values don&rsquo;t look like a very good match to the observed density, but it&rsquo;s probably close enough that an optimizer will be able to find a better solution from there. For the optimizer, we will use Scipy&rsquo;s <a href="https://docs.scipy.org/doc/scipy/reference/optimize.minimize-lbfgsb.html">L-BFGS-B</a> implementation, which is available through the general-purpose <code>scipy.optimize.minimize()</code> function. Here we use JAX&rsquo;s <code>value_and_grad()</code> to get a function handle based on our objective function that returns both the objective value and the gradient with respect to the input parameters. This is where the utility of JAX comes to light: it uses auto-differentiation to compute the gradients for us. We have to set <code>jac=True</code> in <code>minimize()</code> to tell Scipy to expect the gradient along with the objective function value:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> scipy.optimize <span style="color:#66d9ef">as</span> sco
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">res <span style="color:#f92672">=</span> sco<span style="color:#f92672">.</span>minimize(
    jax<span style="color:#f92672">.</span>value_and_grad(GaussianModel<span style="color:#f92672">.</span>objective),
    GaussianModel<span style="color:#f92672">.</span>pack_pars(init_pars),
    args<span style="color:#f92672">=</span>(len(data[<span style="color:#e6db74">&#34;z&#34;</span>]), data),
    jac<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>,
    method<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;l-bfgs-b&#34;</span>,
    options<span style="color:#f92672">=</span>dict(maxiter<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span>),
    bounds<span style="color:#f92672">=</span>[(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">20</span>), (<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>), (<span style="color:#f92672">-</span><span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">5</span>)],
)
res
</code></pre></div><pre><code>      fun: -10.261409577341759
 hess_inv: &lt;3x3 LbfgsInvHessProduct with dtype=float64&gt;
      jac: array([-1.03488418e-08,  2.31515273e-06, -1.50016197e-07])
  message: 'CONVERGENCE: NORM_OF_PROJECTED_GRADIENT_&lt;=_PGTOL'
     nfev: 10
      nit: 8
     njev: 10
   status: 0
  success: True
        x: array([11.5129243 ,  0.02868799, -1.16748798])
</code></pre>
<p>It looks like that optimization completed successfully, and after only 10 function evaluations! Let&rsquo;s look at the density function implied by the optimized parameters:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">opt_pars <span style="color:#f92672">=</span> GaussianModel<span style="color:#f92672">.</span>unpack_pars(res<span style="color:#f92672">.</span>x)

plt<span style="color:#f92672">.</span>plot(xc, dens, drawstyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;steps-mid&#34;</span>, marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)

z_grid <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(z_bins<span style="color:#f92672">.</span>min(), z_bins<span style="color:#f92672">.</span>max(), <span style="color:#ae81ff">1024</span>)
plt<span style="color:#f92672">.</span>plot(
    z_grid,
    np<span style="color:#f92672">.</span>exp(GaussianModel<span style="color:#f92672">.</span>ln_density(z_grid, <span style="color:#f92672">**</span>opt_pars)),
    marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>,
    color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;tab:green&#34;</span>,
)

plt<span style="color:#f92672">.</span>yscale(<span style="color:#e6db74">&#34;log&#34;</span>)

plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;$z$&#34;</span>)
plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;density $n(z)$&#34;</span>);
</code></pre></div><p><img src="output_25_0.png" alt="png"></p>
<p>That looks like a pretty good fit! Let&rsquo;s move on to a more flexible example.</p>
<h2 id="case-2-spline-model">Case 2: Spline model</h2>
<p>We will now replace our density model <code>$n(z)$</code> with a cubic spline representation of the function. We will fix the location of the spline knots by using a hard-set, uniform grid of points in <code>$z$</code>, but the parameters of the model will then be the value of the (log-)density at the locations of the knots. Though there is no jax-ified cubic interpolation built-in to JAX itself (as far as I can tell, it currently only supports linear interpolation), we will use another package — <code>jax_cosmo</code> — which provides a jax-aware version of Scipy&rsquo;s <code>InterpolatedUnivariateSpline</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> jax_cosmo.scipy.interpolate <span style="color:#f92672">import</span> InterpolatedUnivariateSpline
</code></pre></div><p>Awesome, we now have the main tool we need to enable implementing the spline model, however we have one more mathematical / numerical hurdle to solve: we need to be able to compute the integral of our density model to compute the first term in the Poisson process likelihood</p>
<div>$$
\exp{\left[-\int {\rm d}z \, n(z)\right]}
$$</div>
<p>For generic cubic splines, this integral over all <code>$z$</code>&rsquo;s is not finite. We therefore have to pick a domain over which to do this integral, and this then slightly changes the meaning of our parameter <code>ln_N0</code> to be the number of sources <em>in the domain we choose</em>. In practice, if we pick a domain that is large enough and the density function falls off quickly (as it does here), there won&rsquo;t be any practical difference. (But note: if you have a rigid selection region, or if you pick a domain that truncates the data, you have to be more careful than me!) Since our data end around <code>$z\sim \pm 1.5$</code>, we will pick a window of <code>$(-3, 3)$</code>.</p>
<p>We now need a way of computing the integral of our spline model over this domain. If our parameters were the value of the <em>density</em> <code>$N_0$</code> at the locations of the knots, we could use the <code>InterpolatedUnivariateSpline.integral()</code> method directly to compute the integral. However, we use the value of the log-density as parameters, so the integral is not as straightforward. Here, I&rsquo;ve implemented a version of <a href="https://en.wikipedia.org/wiki/Simpson%27s_rule">Simpson&rsquo;s rule</a> that takes in the log-function values and returns the log-integral, which is more stable than using other integration tools that would require first exponentiating the density and then taking the log of the estimated integral value on the outside:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ln_simpson</span>(ln_y, x):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Evaluate the log of the definite integral of a function evaluated on a
</span><span style="color:#e6db74">    grid using Simpson&#39;s rule
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>

    dx <span style="color:#f92672">=</span> jnp<span style="color:#f92672">.</span>diff(x)[<span style="color:#ae81ff">0</span>]
    num_points <span style="color:#f92672">=</span> len(x)
    <span style="color:#66d9ef">if</span> num_points <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> num_points <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>:
        <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">ValueError</span>(<span style="color:#e6db74">&#34;Because of laziness, the input size must be odd&#34;</span>)

    weights_first <span style="color:#f92672">=</span> jnp<span style="color:#f92672">.</span>asarray([<span style="color:#ae81ff">1.0</span>])
    weights_mid <span style="color:#f92672">=</span> jnp<span style="color:#f92672">.</span>tile(jnp<span style="color:#f92672">.</span>asarray([<span style="color:#ae81ff">4.0</span>, <span style="color:#ae81ff">2.0</span>]), [(num_points <span style="color:#f92672">-</span> <span style="color:#ae81ff">3</span>) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>])
    weights_last <span style="color:#f92672">=</span> jnp<span style="color:#f92672">.</span>asarray([<span style="color:#ae81ff">4.0</span>, <span style="color:#ae81ff">1.0</span>])
    weights <span style="color:#f92672">=</span> jnp<span style="color:#f92672">.</span>concatenate([weights_first, weights_mid, weights_last], axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)

    <span style="color:#66d9ef">return</span> jax<span style="color:#f92672">.</span>scipy<span style="color:#f92672">.</span>special<span style="color:#f92672">.</span>logsumexp(ln_y <span style="color:#f92672">+</span> jnp<span style="color:#f92672">.</span>log(weights), axis<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> jnp<span style="color:#f92672">.</span>log(
        dx <span style="color:#f92672">/</span> <span style="color:#ae81ff">3</span>
    )
</code></pre></div><p>With a decision about our integration window and a jax-ified function to compute the value of the log-integral over our spline density function, we can now set up a spline model to fit our toy data:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GaussianSplineModel</span>(Model):
    knots <span style="color:#f92672">=</span> jnp<span style="color:#f92672">.</span>linspace(<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">11</span>)  <span style="color:#75715e"># locations of the spline knots</span>
    param_names <span style="color:#f92672">=</span> {
        <span style="color:#e6db74">&#34;ln_n0&#34;</span>: <span style="color:#ae81ff">11</span>,  <span style="color:#75715e"># the value of the log-density at the knots</span>
    }
    window <span style="color:#f92672">=</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>)  <span style="color:#75715e"># integration window for numerical integral of density</span>
    n_integral_pts <span style="color:#f92672">=</span> <span style="color:#ae81ff">1025</span>  <span style="color:#75715e"># the number of integration grid points to use</span>

    <span style="color:#a6e22e">@staticmethod</span>
    <span style="color:#a6e22e">@jax</span><span style="color:#f92672">.</span>jit
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ln_density</span>(x, ln_n0, knots):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        The log-density is just an evaluation of the spline at the input
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        ln_dens_spl <span style="color:#f92672">=</span> InterpolatedUnivariateSpline(knots, ln_n0, k<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>)
        <span style="color:#66d9ef">return</span> ln_dens_spl(x)

    <span style="color:#a6e22e">@classmethod</span>
    <span style="color:#a6e22e">@partial</span>(jax<span style="color:#f92672">.</span>jit, static_argnums<span style="color:#f92672">=</span>(<span style="color:#ae81ff">0</span>,))
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ln_likelihood</span>(cls, pars, data):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        Implementation of the log-likelihood for an inhomogeneous Poisson
</span><span style="color:#e6db74">        process with underlying density (rate) function given by a spline
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        ln_dens <span style="color:#f92672">=</span> cls<span style="color:#f92672">.</span>ln_density(data[<span style="color:#e6db74">&#34;z&#34;</span>], pars[<span style="color:#e6db74">&#34;ln_n0&#34;</span>], cls<span style="color:#f92672">.</span>knots)

        <span style="color:#75715e"># As mentioned above, to compute the integral over the density, we do</span>
        <span style="color:#75715e"># the integral numerically using Simpson&#39;s rule. For my implementation,</span>
        <span style="color:#75715e"># we must pass in a grid of points and the log of the function to</span>
        <span style="color:#75715e"># integrate evaluated at these grid points. The number of grid points is</span>
        <span style="color:#75715e"># hard-set here, but this should be tuned to meet some accuracy criteria</span>
        V_grid <span style="color:#f92672">=</span> jnp<span style="color:#f92672">.</span>linspace(<span style="color:#f92672">*</span>cls<span style="color:#f92672">.</span>window, cls<span style="color:#f92672">.</span>n_integral_pts)
        ln_V <span style="color:#f92672">=</span> ln_simpson(cls<span style="color:#f92672">.</span>ln_density(V_grid, pars[<span style="color:#e6db74">&#34;ln_n0&#34;</span>], cls<span style="color:#f92672">.</span>knots), V_grid)
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>jnp<span style="color:#f92672">.</span>exp(ln_V) <span style="color:#f92672">+</span> ln_dens<span style="color:#f92672">.</span>sum()

    <span style="color:#a6e22e">@classmethod</span>
    <span style="color:#a6e22e">@partial</span>(jax<span style="color:#f92672">.</span>jit, static_argnums<span style="color:#f92672">=</span>(<span style="color:#ae81ff">0</span>,))
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ln_prior</span>(cls, pars):
        lp <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>
        <span style="color:#66d9ef">for</span> name, p <span style="color:#f92672">in</span> pars<span style="color:#f92672">.</span>items():
            lp <span style="color:#f92672">+=</span> ln_normal(p, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">100</span>)<span style="color:#f92672">.</span>sum()
        <span style="color:#66d9ef">return</span> lp
</code></pre></div><p>With our spline model defined, our integration window set, and our knot locations fixed, we now need to initialize our parameters: the log-density values at the knot locations. We do this by interpolating the estimated density we got from the histogram above at the location of the knots:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">knots <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(xc<span style="color:#f92672">.</span>min(), xc<span style="color:#f92672">.</span>max(), <span style="color:#ae81ff">11</span>)
knots_ln_dens <span style="color:#f92672">=</span> sci<span style="color:#f92672">.</span>InterpolatedUnivariateSpline(xc, np<span style="color:#f92672">.</span>log(dens <span style="color:#f92672">+</span> <span style="color:#ae81ff">1e-8</span>), k<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>)(
    GaussianSplineModel<span style="color:#f92672">.</span>knots
)

plt<span style="color:#f92672">.</span>plot(xc, dens, drawstyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;steps-mid&#34;</span>, marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)
plt<span style="color:#f92672">.</span>scatter(
    GaussianSplineModel<span style="color:#f92672">.</span>knots,
    np<span style="color:#f92672">.</span>exp(knots_ln_dens),
    color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;tab:blue&#34;</span>,
    label<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;knots - initial&#34;</span>,
)
plt<span style="color:#f92672">.</span>yscale(<span style="color:#e6db74">&#34;log&#34;</span>)

plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;$z$&#34;</span>)
plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;density $n(z)$&#34;</span>)

plt<span style="color:#f92672">.</span>legend(loc<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;best&#34;</span>)
</code></pre></div><pre><code>&lt;matplotlib.legend.Legend at 0x7faeba10b4c0&gt;
</code></pre>
<p><img src="output_33_1.png" alt="png"></p>
<p>We can now run the optimizer with our new spline model for the density:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># We add a little bit of random scatter just to make things interesting...</span>
init_pars <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;ln_n0&#34;</span>: knots_ln_dens <span style="color:#f92672">+</span> rng<span style="color:#f92672">.</span>uniform(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0.1</span>, size<span style="color:#f92672">=</span>len(knots))}
res <span style="color:#f92672">=</span> sco<span style="color:#f92672">.</span>minimize(
    jax<span style="color:#f92672">.</span>value_and_grad(GaussianSplineModel<span style="color:#f92672">.</span>objective),
    GaussianSplineModel<span style="color:#f92672">.</span>pack_pars(init_pars),
    args<span style="color:#f92672">=</span>(len(data[<span style="color:#e6db74">&#34;z&#34;</span>]), data),
    jac<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>,
    method<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;l-bfgs-b&#34;</span>,
    options<span style="color:#f92672">=</span>dict(maxiter<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span>, maxls<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span>),  <span style="color:#75715e"># I had to increase maxls to succeed</span>
)
res
</code></pre></div><pre><code>      fun: -10.260887909516791
 hess_inv: &lt;11x11 LbfgsInvHessProduct with dtype=float64&gt;
      jac: array([-2.86425740e-06,  6.56002702e-06, -4.06564716e-05, -1.03612167e-05,
       -1.46661050e-06, -3.35053437e-06,  5.02995779e-06,  6.29047702e-06,
        1.88062757e-05, -6.78824477e-06, -1.25840325e-06])
  message: 'CONVERGENCE: REL_REDUCTION_OF_F_&lt;=_FACTR*EPSMCH'
     nfev: 37
      nit: 33
     njev: 37
   status: 0
  success: True
        x: array([-18.01096061, -19.45263838, -11.97307253,   2.68899672,
         9.73834031,  11.76439384,  10.06449883,   4.95208879,
        -4.7820572 , -21.05344694, -18.43766302])
</code></pre>
<p>Let&rsquo;s plot our optimized spline density function and the value at the knots over our data:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">plt<span style="color:#f92672">.</span>plot(xc, dens, drawstyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;steps-mid&#34;</span>, marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)

opt_pars <span style="color:#f92672">=</span> GaussianSplineModel<span style="color:#f92672">.</span>unpack_pars(res<span style="color:#f92672">.</span>x)

_grid <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#f92672">*</span>GaussianSplineModel<span style="color:#f92672">.</span>window, <span style="color:#ae81ff">1024</span>)
plt<span style="color:#f92672">.</span>plot(
    _grid,
    np<span style="color:#f92672">.</span>exp(
        GaussianSplineModel<span style="color:#f92672">.</span>ln_density(
            _grid, opt_pars[<span style="color:#e6db74">&#34;ln_n0&#34;</span>], GaussianSplineModel<span style="color:#f92672">.</span>knots
        )
    ),
    marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>,
    color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;tab:green&#34;</span>,
)
plt<span style="color:#f92672">.</span>scatter(
    GaussianSplineModel<span style="color:#f92672">.</span>knots,
    np<span style="color:#f92672">.</span>exp(opt_pars[<span style="color:#e6db74">&#34;ln_n0&#34;</span>]),
    color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;tab:blue&#34;</span>,
    label<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;knots - optimized&#34;</span>,
)

plt<span style="color:#f92672">.</span>yscale(<span style="color:#e6db74">&#34;log&#34;</span>)

plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;$z$&#34;</span>)
plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;density $n(z)$&#34;</span>)

plt<span style="color:#f92672">.</span>legend(loc<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;best&#34;</span>)
</code></pre></div><pre><code>&lt;matplotlib.legend.Legend at 0x7faeb76f8220&gt;
</code></pre>
<p><img src="output_37_1.png" alt="png"></p>
<p>Excellent - this also looks like a great fit! Unexpectedly, weird things happen outside of the range where we have data, but here the splines will largely be unconstrained.</p>
<p>Now that we have optimized parameters, and we have a model class with a function that computes the log-posterior probability given data, we can use the optimized parameter values to initialize an MCMC sampling of the parameters. To do this, we will use the <a href="https://blackjax-devs.github.io/blackjax/">blackjax</a> package to run a Hamiltonian Monte Carlo (HMC) sampler. In detail, we will use the NUTS sampler, and we will use their implementation of a window adaptation method to find good choices for the sampler parameters (step size and inverse mass matrix). This code follows the example code from the &ldquo;<a href="https://blackjax-devs.github.io/blackjax/examples/Introduction.html#nuts">quick introduction to blackjax</a>&rdquo; in the blackjax documentation.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> blackjax
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># This is the main loop that does the sampling for us:</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inference_loop</span>(rng_key, kernel, initial_state, num_samples):
    <span style="color:#a6e22e">@jax</span><span style="color:#f92672">.</span>jit
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">one_step</span>(state, rng_key):
        state, _ <span style="color:#f92672">=</span> kernel(rng_key, state)
        <span style="color:#66d9ef">return</span> state, state

    keys <span style="color:#f92672">=</span> jax<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>split(rng_key, num_samples)
    _, states <span style="color:#f92672">=</span> jax<span style="color:#f92672">.</span>lax<span style="color:#f92672">.</span>scan(one_step, initial_state, keys)

    <span style="color:#66d9ef">return</span> states
</code></pre></div><p>We start by using the blackjax implementation of STAN&rsquo;s window adaptation method to find good choices for the NUTS sampler parameters:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">rng_key <span style="color:#f92672">=</span> jax<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>PRNGKey(<span style="color:#ae81ff">42</span>)

fn <span style="color:#f92672">=</span> jax<span style="color:#f92672">.</span>tree_util<span style="color:#f92672">.</span>Partial(GaussianSplineModel<span style="color:#f92672">.</span>ln_posterior, data<span style="color:#f92672">=</span>data)
warmup <span style="color:#f92672">=</span> blackjax<span style="color:#f92672">.</span>window_adaptation(
    blackjax<span style="color:#f92672">.</span>nuts,
    fn,
    <span style="color:#ae81ff">1000</span>,
)

state, kernel, _ <span style="color:#f92672">=</span> warmup<span style="color:#f92672">.</span>run(
    rng_key,
    res<span style="color:#f92672">.</span>x,
)
</code></pre></div><p>With a tuned kernel, we can now run our main inference loop to generate 1000 posterior samples of our parameters:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">states <span style="color:#f92672">=</span> inference_loop(rng_key, kernel, state, <span style="color:#ae81ff">1_000</span>)
</code></pre></div><p>Let&rsquo;s see how these look! As a quick check, let&rsquo;s look at a trace plot of a few of the parameters:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">8</span>]:
    plt<span style="color:#f92672">.</span>plot(states<span style="color:#f92672">.</span>position[:, i], marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>, drawstyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;steps-mid&#34;</span>)

plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;NUTS step&#34;</span>)
plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;parameter value&#34;</span>)
</code></pre></div><pre><code>Text(0, 0.5, 'parameter value')
</code></pre>
<p><img src="output_46_1.png" alt="png"></p>
<p>Those look stable! Of course, we should compute some convergence statistics and check on the quality of our samples. But for now, we&rsquo;ll assume that our &ldquo;by-eye&rdquo; test is good enough, and proceed :).</p>
<p>For each posterior sample of our parameters, let&rsquo;s compute the implied density function and store these in a big 2D array:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">_grid <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#f92672">*</span>GaussianSplineModel<span style="color:#f92672">.</span>window, <span style="color:#ae81ff">1024</span>)
ln_dens_samples <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros((states<span style="color:#f92672">.</span>position<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>], len(_grid)))
<span style="color:#66d9ef">for</span> i, params <span style="color:#f92672">in</span> enumerate(states<span style="color:#f92672">.</span>position):
    ln_dens_samples[i] <span style="color:#f92672">=</span> GaussianSplineModel<span style="color:#f92672">.</span>ln_density(
        _grid, params, GaussianSplineModel<span style="color:#f92672">.</span>knots
    )
</code></pre></div><p>We can now visualize the 16–84th percentile range of our inferred density function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">5</span>))
plt<span style="color:#f92672">.</span>fill_between(
    _grid,
    <span style="color:#f92672">*</span>np<span style="color:#f92672">.</span>percentile(np<span style="color:#f92672">.</span>exp(ln_dens_samples), [<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">84</span>], axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>),
    color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;tab:blue&#34;</span>,
    alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.4</span>,
    linewidth<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
)
plt<span style="color:#f92672">.</span>plot(
    _grid,
    np<span style="color:#f92672">.</span>median(np<span style="color:#f92672">.</span>exp(ln_dens_samples), axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>),
    color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;tab:blue&#34;</span>,
    linewidth<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>,
    marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>,
)
plt<span style="color:#f92672">.</span>yscale(<span style="color:#e6db74">&#34;log&#34;</span>)

plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;$z$&#34;</span>)
plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;density $n(z)$&#34;</span>);
</code></pre></div><p><img src="output_50_0.png" alt="png"></p>
<p>As we might expect, the density function is not well constrained beyond <code>$|z|\gtrsim 2$</code> or so where we do not have data.</p>
<p>Now that we have a better picture of how to implement these types of flexible spline models with JAX, let&rsquo;s turn to a more complicated science example.</p>
<hr>
<h1 id="example-fitting-the-density-profile-and-track-of-a-stellar-stream">Example: Fitting the density profile and track of a stellar stream</h1>
<p>Building off of the 1D spline model we used above, we are now going to move on to a more complicated example motivated by my own research. Here we will try to model the 2D (on sky) density of a <a href="https://en.wikipedia.org/wiki/Stellar_kinematics#Stellar_streams">stellar stream</a> known as the &ldquo;GD-1 stream&rdquo; (named after its discovers <a href="https://ui.adsabs.harvard.edu/abs/2006ApJ...643L..17G/abstract">Grillmair &amp; Dionatos</a>). There is too much context to cover here, but for the purposes of this demo, assume that we are given a list of sky positions of stars from Gaia and we would like to model the on-sky density of the stream and background to (a) characterize the track of the stream, and (b) identify probable member stars. (The stars we will use have actually been pre-filtered to select distant, low-metallicity, main-sequence stars with proper motions that match the <a href="https://ui.adsabs.harvard.edu/abs/2018ApJ...863L..20P/abstract">previously-fit track of the stream</a>)</p>
<p>Let&rsquo;s start by loading the data, which is included in this repository as a FITS file, so we can load the catalog using <a href="https://docs.astropy.org/en/stable/table/index.html"><code>astropy.table</code></a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> astropy.table <span style="color:#66d9ef">as</span> at
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">gd1_tbl <span style="color:#f92672">=</span> at<span style="color:#f92672">.</span>Table<span style="color:#f92672">.</span>read(<span style="color:#e6db74">&#34;data/gd1-gaiadr3-blog.fits&#34;</span>)

<span style="color:#75715e"># We will apply one additional selection criteria to limit the number of stars we have to handle:</span>
gd1_tbl <span style="color:#f92672">=</span> gd1_tbl[gd1_tbl[<span style="color:#e6db74">&#34;gd1_phi2&#34;</span>] <span style="color:#f92672">&gt;</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">7</span>]
len(gd1_tbl)
</code></pre></div><pre><code>2960
</code></pre>
<p>The table contains many columns from <a href="https://gea.esac.esa.int/archive/">Gaia DR3</a>, along with some photometry from the Pan-STARS PS1 survey (<a href="https://mastweb.stsci.edu/">data release 2</a>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">gd1_tbl<span style="color:#f92672">.</span>colnames
</code></pre></div><pre><code>['source_id',
 'ra',
 'dec',
 'parallax',
 'parallax_error',
 'pmra',
 'pmra_error',
 'pmdec',
 'pmdec_error',
 'ra_parallax_corr',
 'ra_pmra_corr',
 'ra_pmdec_corr',
 'dec_parallax_corr',
 'dec_pmra_corr',
 'dec_pmdec_corr',
 'parallax_pmra_corr',
 'parallax_pmdec_corr',
 'pmra_pmdec_corr',
 'phot_g_mean_mag',
 'phot_g_mean_flux_over_error',
 'phot_bp_mean_mag',
 'phot_bp_mean_flux_over_error',
 'phot_rp_mean_mag',
 'phot_rp_mean_flux_over_error',
 'ruwe',
 'gd1_phi1',
 'gd1_phi2',
 'objID',
 'raMean',
 'decMean',
 'nDetections',
 'ng',
 'nr',
 'ni',
 'nz',
 'ny',
 'gMeanPSFMag',
 'rMeanPSFMag',
 'iMeanPSFMag',
 'zMeanPSFMag',
 'yMeanPSFMag',
 'gMeanPSFMagErr',
 'rMeanPSFMagErr',
 'iMeanPSFMagErr',
 'zMeanPSFMagErr',
 'yMeanPSFMagErr',
 'sep_arcsec']
</code></pre>
<p>However, the only two columns we will use here are <code>gd1_phi1</code> and <code>gd1_phi2</code>, which are the sky positions of stars in a coordinate system in which the GD-1 stream lies approximately along latitude=0 (the coordinate system was defined in Koposov et al. 2010 and is implemented as an <code>astropy.coordinates</code> frame in the <a href="https://gala.adrian.pw">gala</a> package in <a href="http://gala.adrian.pw/en/latest/api/gala.coordinates.GD1Koposov10.html">gala.coordinates</a>).</p>
<p>Let&rsquo;s start by making a scatter plot of the sky positions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">fig, ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">3</span>), constrained_layout<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
ax<span style="color:#f92672">.</span>plot(
    gd1_tbl[<span style="color:#e6db74">&#34;gd1_phi1&#34;</span>],
    gd1_tbl[<span style="color:#e6db74">&#34;gd1_phi2&#34;</span>],
    marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;o&#34;</span>,
    markeredgewidth<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,
    markersize<span style="color:#f92672">=</span><span style="color:#ae81ff">3.0</span>,
    ls<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;none&#34;</span>,
    alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.25</span>,
)
ax<span style="color:#f92672">.</span>set_xlim(<span style="color:#f92672">-</span><span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">20</span>)
ax<span style="color:#f92672">.</span>set_ylim(<span style="color:#f92672">-</span><span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">5</span>)

ax<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">&#34;$\phi_1$ [deg]&#34;</span>)
ax<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">&#34;$\phi_2$ [deg]&#34;</span>);
</code></pre></div><p><img src="output_58_0.png" alt="png"></p>
<h2 id="defining-the-density-model">Defining the density model</h2>
<p>The curved over-density of stars that arcs from <code>$(\phi_1, \phi_2) \sim (-80, -3)^\circ$</code> to <code>$(\phi_1, \phi_2) \sim (-40, 0)^\circ$</code> to <code>$(\phi_1, \phi_2) \sim (0, -2)^\circ$</code> is the GD-1 stream. This is the density distribution we would like to model using a flexible, spline-based density function. Given the complexity of the stream, we will clearly have to be a bit more baroque in our model specification relative to the previous example. Additionally, there is a non-negligible background density of stars that varies (more smoothly) over the sky region where the stream exists: we will have to simultaneously model this background distribution:</p>
<ul>
<li>To represent the background, we will assume that the density is only a function of <code>$\phi_1$</code> and can be represented as a spline with evenly-spaced knots between <code>$\phi_1 \in [-120, 40]^\circ$</code>.</li>
<li>To represent the amplitude of the density of the stream, we will again use a spline as a function of <code>$\phi_1$</code> with equally-spaced knot locations, now between <code>$\phi_1 \in [-110, 30]^\circ$</code>. Because the density of the stream varies on scales of just a few degrees, we use many more knots to represent the stream density.</li>
<li>To represent the 2D density distribution of the stream, we use a Gaussian in <code>$\phi_2$</code> where the mean and standard deviation of the Gaussian are set by spline functions of <code>$\phi_1$</code>. We use the same knot locations for both the mean and standard deviation.</li>
</ul>
<p>Here we also adopt a &ldquo;smoothness&rdquo; prior on the spline values: We assume that the prior on a given <code>$m$</code> spline value is Gaussian with a mean set by the value of the <code>$m-1$</code> knot and fixed standard deviations (defined below). For example, for the stream track (or mean <code>$\phi_2$</code> location <code>$\mu_{\phi_2}$</code>), the prior on the <code>$m$</code>-th mean value is</p>
<div>$$
p(\mu_{\phi_2}^{(m)}) = \mathcal{N}(\mu_{\phi_2}^{(m)} \,|\, \mu_{\phi_2}^{(m-1)}, 0.5^\circ)
$$</div>
<p>This density model is a <em>mixture model</em> in that we have two main components of the model: the stream density and the background (bkg) stellar density. What this means in math is that the full density function <code>$n(\phi_1, \phi_2)$</code> can be expressed as the sum of the two components</p>
<div>$$
n(\phi_1, \phi_2) = n_{\rm stream}(\phi_1, \phi_2) + n_{\rm bkg}(\phi_1, \phi_2)
$$</div>
<p>For numerical stability, we typically work in the log-density instead of the density. Here, that means:</p>
<div>$$
\ln n(\phi_1, \phi_2) = \ln\left[n_{\rm stream}(\phi_1, \phi_2) + n_{\rm bkg}(\phi_1, \phi_2)\right]
$$</div>
<p>But because of the sum, you might think we are stuck adding (potentially) large numbers before taking the log. Luckily, there is a trick for handling cases like this that appears in many different statistics and data science applications known as <a href="https://gregorygundersen.com/blog/2020/02/09/log-sum-exp/">&ldquo;logsumexp&rdquo;</a>, which you will see me use below when combining the individual densities.</p>
<p>As a final point, as was the case with our 1D spline model from Example 1, the integral over the full 2D density function (including the background model and stream model components) is not easily expressible in closed form, but we can use the same numerical integration trick we used above for this model.</p>
<p>The model is more complex than the 1D models, but I will describe each element of the model below using comments:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StreamModel</span>(Model):
    <span style="color:#75715e"># The phi_1 locations of the knots used for representing the background density:</span>
    bkg_knots <span style="color:#f92672">=</span> jnp<span style="color:#f92672">.</span>linspace(<span style="color:#f92672">-</span><span style="color:#ae81ff">120</span>, <span style="color:#ae81ff">40</span>, <span style="color:#ae81ff">7</span>)

    <span style="color:#75715e"># The phi_1 locations of the knots used for representing the density along the stream,</span>
    <span style="color:#75715e"># and for representing the mean and standard deviation of the stream density in the</span>
    <span style="color:#75715e"># phi_2 direction:</span>
    ln_n0_knots <span style="color:#f92672">=</span> jnp<span style="color:#f92672">.</span>linspace(<span style="color:#f92672">-</span><span style="color:#ae81ff">110</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">31</span>)
    phi2_knots <span style="color:#f92672">=</span> jnp<span style="color:#f92672">.</span>linspace(<span style="color:#f92672">-</span><span style="color:#ae81ff">110</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">17</span>)

    param_names <span style="color:#f92672">=</span> {
        <span style="color:#e6db74">&#34;ln_n0&#34;</span>: len(ln_n0_knots),  <span style="color:#75715e"># The value of the stream density at the knots</span>
        <span style="color:#e6db74">&#34;mean_phi2&#34;</span>: len(phi2_knots),  <span style="color:#75715e"># The mean phi_2 location of the stream</span>
        <span style="color:#e6db74">&#34;ln_std_phi2&#34;</span>: len(phi2_knots),  <span style="color:#75715e"># The stddev in phi_2 of the stream</span>
        <span style="color:#e6db74">&#34;ln_n0_bkg&#34;</span>: len(bkg_knots),  <span style="color:#75715e"># The value of the background density</span>
    }

    <span style="color:#75715e"># Here we pre-define the grids we will use to perform the numerical integration of</span>
    <span style="color:#75715e"># the density over our data window phi_1 in (-100, 20) and phi_2 in (-7, 5).</span>
    <span style="color:#75715e"># A quick note that because I use Simpson&#39;s rule for integration, we have to choose</span>
    <span style="color:#75715e"># a fixed grid to perform the integral on. I had initially chosen a step size of</span>
    <span style="color:#75715e"># 0.2º but ran into many issues with the optimizer not being able to find a</span>
    <span style="color:#75715e"># successful solution. I increased the resolution of the integration grid and it</span>
    <span style="color:#75715e"># seems to work for me, but a caveat here is that there will be some sensitivity to</span>
    <span style="color:#75715e"># the choice of integration grid. We could use an adaptive method, but I didn&#39;t find</span>
    <span style="color:#75715e"># a good log implementation like we have here for Simpson&#39;s rule.</span>
    integ_grid_phi1_1d <span style="color:#f92672">=</span> jnp<span style="color:#f92672">.</span>arange(<span style="color:#f92672">-</span><span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">20</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1e-3</span>, <span style="color:#ae81ff">0.1</span>)
    integ_grid_phi2_1d <span style="color:#f92672">=</span> jnp<span style="color:#f92672">.</span>arange(<span style="color:#f92672">-</span><span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1e-3</span>, <span style="color:#ae81ff">0.1</span>)
    integ_grid_phi1, integ_grid_phi2 <span style="color:#f92672">=</span> jnp<span style="color:#f92672">.</span>meshgrid(
        integ_grid_phi1_1d, integ_grid_phi2_1d
    )

    <span style="color:#a6e22e">@classmethod</span>
    <span style="color:#a6e22e">@partial</span>(jax<span style="color:#f92672">.</span>jit, static_argnums<span style="color:#f92672">=</span>(<span style="color:#ae81ff">0</span>,))
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ln_density_stream</span>(cls, phi1, phi2, ln_n0, mean_phi2, ln_std_phi2):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        This function evaluates the log-density of the stream component of the model
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        <span style="color:#75715e"># As in the 1D example above, we construct interpolating splines given the</span>
        <span style="color:#75715e"># pre-determined knot locations, with values given as input (i.e. parameters)</span>
        ln_n0_spl <span style="color:#f92672">=</span> InterpolatedUnivariateSpline(cls<span style="color:#f92672">.</span>ln_n0_knots, ln_n0, k<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>)
        mean_phi2_spl <span style="color:#f92672">=</span> InterpolatedUnivariateSpline(cls<span style="color:#f92672">.</span>phi2_knots, mean_phi2, k<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>)
        ln_std_phi2_spl <span style="color:#f92672">=</span> InterpolatedUnivariateSpline(cls<span style="color:#f92672">.</span>phi2_knots, ln_std_phi2, k<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>)

        <span style="color:#75715e"># We evaluate the splines at the locations of the input data phi1, phi2:</span>
        ln_dens <span style="color:#f92672">=</span> ln_n0_spl(phi1) <span style="color:#f92672">+</span> ln_normal(
            phi2, mean_phi2_spl(phi1), jnp<span style="color:#f92672">.</span>exp(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> ln_std_phi2_spl(phi1))
        )

        <span style="color:#66d9ef">return</span> ln_dens

    <span style="color:#a6e22e">@classmethod</span>
    <span style="color:#a6e22e">@partial</span>(jax<span style="color:#f92672">.</span>jit, static_argnums<span style="color:#f92672">=</span>(<span style="color:#ae81ff">0</span>,))
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ln_density_bkg</span>(cls, phi1, phi2, ln_n0_bkg):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        This function evaluates the log-density of the background stellar density
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        ln_n0_spl <span style="color:#f92672">=</span> InterpolatedUnivariateSpline(cls<span style="color:#f92672">.</span>bkg_knots, ln_n0_bkg, k<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>)
        <span style="color:#66d9ef">return</span> ln_n0_spl(phi1)

    <span style="color:#a6e22e">@classmethod</span>
    <span style="color:#a6e22e">@partial</span>(jax<span style="color:#f92672">.</span>jit, static_argnums<span style="color:#f92672">=</span>(<span style="color:#ae81ff">0</span>,))
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ln_density</span>(cls, phi1, phi2, ln_n0, mean_phi2, ln_std_phi2, ln_n0_bkg):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        This evaluates the total model density
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        ln_dens1 <span style="color:#f92672">=</span> cls<span style="color:#f92672">.</span>ln_density_stream(phi1, phi2, ln_n0, mean_phi2, ln_std_phi2)
        ln_dens2 <span style="color:#f92672">=</span> cls<span style="color:#f92672">.</span>ln_density_bkg(
            phi1,
            phi2,
            ln_n0_bkg,
        )

        <span style="color:#75715e"># Note: this is the &#34;logsumexp&#34; trick mentioned above:</span>
        ln_dens <span style="color:#f92672">=</span> jnp<span style="color:#f92672">.</span>logaddexp(ln_dens1, ln_dens2)
        <span style="color:#66d9ef">return</span> ln_dens

    <span style="color:#a6e22e">@classmethod</span>
    <span style="color:#a6e22e">@partial</span>(jax<span style="color:#f92672">.</span>jit, static_argnums<span style="color:#f92672">=</span>(<span style="color:#ae81ff">0</span>,))
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ln_likelihood</span>(cls, pars, data):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        Implementation of the log-likelihood for an inhomogeneous Poisson
</span><span style="color:#e6db74">        process with underlying density (rate) function
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        ln_dens <span style="color:#f92672">=</span> cls<span style="color:#f92672">.</span>ln_density(
            data[<span style="color:#e6db74">&#34;phi1&#34;</span>],
            data[<span style="color:#e6db74">&#34;phi2&#34;</span>],
            pars[<span style="color:#e6db74">&#34;ln_n0&#34;</span>],
            pars[<span style="color:#e6db74">&#34;mean_phi2&#34;</span>],
            pars[<span style="color:#e6db74">&#34;ln_std_phi2&#34;</span>],
            pars[<span style="color:#e6db74">&#34;ln_n0_bkg&#34;</span>],
        )

        <span style="color:#75715e"># Here is where we perform the log-integral over n(phi1, phi2) using Simpson&#39;s</span>
        <span style="color:#75715e"># rule. We evauate the log-density function on our pre-defined 2D grid, and use</span>
        <span style="color:#75715e"># the ln_simpson() function defined above twice to compute the integral:</span>
        ln_dens_grid <span style="color:#f92672">=</span> cls<span style="color:#f92672">.</span>ln_density(cls<span style="color:#f92672">.</span>integ_grid_phi1, cls<span style="color:#f92672">.</span>integ_grid_phi2, <span style="color:#f92672">**</span>pars)
        ln_V <span style="color:#f92672">=</span> ln_simpson(
            ln_simpson(ln_dens_grid, cls<span style="color:#f92672">.</span>integ_grid_phi1_1d), cls<span style="color:#f92672">.</span>integ_grid_phi2_1d
        )
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>jnp<span style="color:#f92672">.</span>exp(ln_V) <span style="color:#f92672">+</span> ln_dens<span style="color:#f92672">.</span>sum()

    <span style="color:#a6e22e">@classmethod</span>
    <span style="color:#a6e22e">@partial</span>(jax<span style="color:#f92672">.</span>jit, static_argnums<span style="color:#f92672">=</span>(<span style="color:#ae81ff">0</span>,))
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ln_prior</span>(cls, pars):
        lp <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>

        <span style="color:#75715e"># The loops below implement the &#34;smoothness&#34; priors on the splines that was</span>
        <span style="color:#75715e"># mentioned above. The standard deviation values were picked arbitrarily to</span>
        <span style="color:#75715e"># enforce some smoothness, but to not be too aggressive:</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(cls<span style="color:#f92672">.</span>ln_n0_knots)):
            lp <span style="color:#f92672">+=</span> ln_normal(pars[<span style="color:#e6db74">&#34;ln_n0&#34;</span>][i], pars[<span style="color:#e6db74">&#34;ln_n0&#34;</span>][i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">1</span>)

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(cls<span style="color:#f92672">.</span>phi2_knots)):
            lp <span style="color:#f92672">+=</span> ln_normal(pars[<span style="color:#e6db74">&#34;mean_phi2&#34;</span>][i], pars[<span style="color:#e6db74">&#34;mean_phi2&#34;</span>][i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">1</span>)

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(cls<span style="color:#f92672">.</span>phi2_knots)):
            lp <span style="color:#f92672">+=</span> ln_normal(pars[<span style="color:#e6db74">&#34;ln_std_phi2&#34;</span>][i], pars[<span style="color:#e6db74">&#34;ln_std_phi2&#34;</span>][i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">1</span>)

        <span style="color:#66d9ef">return</span> lp
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">StreamModel<span style="color:#f92672">.</span>integ_grid_phi1<span style="color:#f92672">.</span>shape, StreamModel<span style="color:#f92672">.</span>integ_grid_phi2<span style="color:#f92672">.</span>shape
</code></pre></div><pre><code>((121, 1201), (121, 1201))
</code></pre>
<p>Now that we have our density model class defined, let&rsquo;s start by computing the density on a 2D grid with some randomly chosen parameter values (i.e. spline knot values). To visualize the density, we will use the 2D integration grid we defined above as <code>StreamModel.integ_grid_phi1</code> and <code>StreamModel.integ_grid_phi2</code> for <code>$\phi_1$</code> and <code>$\phi_2$</code> values, respectively:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">rng <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>default_rng(seed<span style="color:#f92672">=</span><span style="color:#ae81ff">666</span>)

<span style="color:#75715e"># Random values for the stream splines:</span>
ln_n0 <span style="color:#f92672">=</span> rng<span style="color:#f92672">.</span>uniform(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, size<span style="color:#f92672">=</span>len(StreamModel<span style="color:#f92672">.</span>ln_n0_knots))
mean_phi2 <span style="color:#f92672">=</span> rng<span style="color:#f92672">.</span>uniform(<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, size<span style="color:#f92672">=</span>len(StreamModel<span style="color:#f92672">.</span>phi2_knots))
ln_std_phi2 <span style="color:#f92672">=</span> rng<span style="color:#f92672">.</span>uniform(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, size<span style="color:#f92672">=</span>len(StreamModel<span style="color:#f92672">.</span>phi2_knots))
ln_dens <span style="color:#f92672">=</span> StreamModel<span style="color:#f92672">.</span>ln_density_stream(
    StreamModel<span style="color:#f92672">.</span>integ_grid_phi1,
    StreamModel<span style="color:#f92672">.</span>integ_grid_phi2,
    ln_n0,
    mean_phi2,
    ln_std_phi2,
)

<span style="color:#75715e"># And the background density:</span>
ln_n0_bkg <span style="color:#f92672">=</span> rng<span style="color:#f92672">.</span>uniform(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, size<span style="color:#f92672">=</span>len(StreamModel<span style="color:#f92672">.</span>bkg_knots))
ln_dens_bkg <span style="color:#f92672">=</span> StreamModel<span style="color:#f92672">.</span>ln_density_bkg(
    StreamModel<span style="color:#f92672">.</span>integ_grid_phi1, StreamModel<span style="color:#f92672">.</span>integ_grid_phi2, ln_n0_bkg
)

fig, axes <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(
    <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">4</span>), sharex<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, sharey<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, constrained_layout<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>
)
axes[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>pcolormesh(
    StreamModel<span style="color:#f92672">.</span>integ_grid_phi1, StreamModel<span style="color:#f92672">.</span>integ_grid_phi2, np<span style="color:#f92672">.</span>exp(ln_dens)
)
axes[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#34;stream component&#34;</span>)
axes[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>pcolormesh(
    StreamModel<span style="color:#f92672">.</span>integ_grid_phi1, StreamModel<span style="color:#f92672">.</span>integ_grid_phi2, np<span style="color:#f92672">.</span>exp(ln_dens_bkg)
)
axes[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#34;background component&#34;</span>)

<span style="color:#66d9ef">for</span> ax <span style="color:#f92672">in</span> axes:
    ax<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;$\phi_2$ [deg]&#34;</span>)
axes[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;$\phi_1$ [deg]&#34;</span>)
</code></pre></div><pre><code>Text(0.5, 0, '$\\phi_1$ [deg]')
</code></pre>
<p><img src="output_63_1.png" alt="png"></p>
<h2 id="initializing-the-density-model-parameters">Initializing the density model parameters</h2>
<p>In many real-world optimization problems, especially those with many parameters like we have here, a good initialization is often important for success (or at least speed) of the optimizer. We could try initializing the stream model and background with random settings of the parameter (as we visualized above), but it&rsquo;s usually worth spending a bit of time estimating better initial guesses for your parameters.</p>
<p>We will therefore spend a few cells below manipulating the data to estimate the rough on-sky track and density of the stream, and the density of the stellar background.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> scipy.ndimage <span style="color:#f92672">import</span> gaussian_filter1d
</code></pre></div><p>There are many ways we could do this, but in the cell below I bin the data coarsely in <code>$\phi_1$</code> and fine in <code>$\phi_2$</code>, smooth the data, and find the location of the peak in <code>$\phi_2$</code> in the coarse <code>$\phi_1$</code> bins. I then convert the number counts to density so we can extract the rough track of the stream in <code>$\phi_1, \phi_2$</code> along with a density estimate at each of these locations.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">H, xe, ye <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>histogram2d(
    gd1_tbl[<span style="color:#e6db74">&#34;gd1_phi1&#34;</span>],
    gd1_tbl[<span style="color:#e6db74">&#34;gd1_phi2&#34;</span>],
    bins<span style="color:#f92672">=</span>(np<span style="color:#f92672">.</span>linspace(<span style="color:#f92672">-</span><span style="color:#ae81ff">90</span>, <span style="color:#ae81ff">20</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1e-3</span>, <span style="color:#ae81ff">11</span>), np<span style="color:#f92672">.</span>arange(<span style="color:#f92672">-</span><span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1e-3</span>, <span style="color:#ae81ff">0.2</span>)),
)
xc <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">*</span> (xe[:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> xe[<span style="color:#ae81ff">1</span>:])
yc <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">*</span> (ye[:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> ye[<span style="color:#ae81ff">1</span>:])

H <span style="color:#f92672">=</span> gaussian_filter1d(H, sigma<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
H <span style="color:#f92672">-=</span> np<span style="color:#f92672">.</span>mean(H[:, (yc <span style="color:#f92672">&lt;</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">5</span>) <span style="color:#f92672">|</span> (yc <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">3</span>)])

H <span style="color:#f92672">/=</span> (xe[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> xe[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">/</span> <span style="color:#ae81ff">12</span>
H_density <span style="color:#f92672">=</span> H<span style="color:#f92672">.</span>copy()

peak_idx <span style="color:#f92672">=</span> H<span style="color:#f92672">.</span>argmax(axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
H <span style="color:#f92672">/=</span> H[np<span style="color:#f92672">.</span>arange(H<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>]), peak_idx][:, <span style="color:#66d9ef">None</span>]
H_ln_density <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>log(H_density[np<span style="color:#f92672">.</span>arange(H<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>]), peak_idx])


fig, axes <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">6</span>), sharex<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, constrained_layout<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
cs <span style="color:#f92672">=</span> axes[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>pcolormesh(xe, ye, H<span style="color:#f92672">.</span>T, vmin<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, vmax<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, cmap<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Greys&#34;</span>)
axes[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>plot(xc, yc[peak_idx], color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;tab:red&#34;</span>)
axes[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;$\phi_2$&#34;</span>)
axes[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>plot(xc, H_ln_density)
axes[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;log-density&#34;</span>)
axes[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;$\phi_1$&#34;</span>)
</code></pre></div><pre><code>Text(0.5, 0, '$\\phi_1$')
</code></pre>
<p><img src="output_67_1.png" alt="png"></p>
<p>We now have to interpolate these estimates to the location of our spline knots to set the initial parameters of our stream model:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">init_ln_n0 <span style="color:#f92672">=</span> sci<span style="color:#f92672">.</span>InterpolatedUnivariateSpline(xc, H_ln_density)(StreamModel<span style="color:#f92672">.</span>ln_n0_knots)

init_mean_phi2 <span style="color:#f92672">=</span> sci<span style="color:#f92672">.</span>InterpolatedUnivariateSpline(xc, yc[peak_idx])(
    StreamModel<span style="color:#f92672">.</span>phi2_knots
)
</code></pre></div><p>Next we will handle the stellar background. Here, we select stars above and below the stream (in <code>$\phi_2$</code>), estimate the 1D density of the background using a histogram, and smooth the estimates.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">_mask <span style="color:#f92672">=</span> (gd1_tbl[<span style="color:#e6db74">&#34;gd1_phi2&#34;</span>] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">3</span>) <span style="color:#f92672">|</span> (gd1_tbl[<span style="color:#e6db74">&#34;gd1_phi2&#34;</span>] <span style="color:#f92672">&lt;</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">5</span>)
H, xe <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>histogram(gd1_tbl[<span style="color:#e6db74">&#34;gd1_phi1&#34;</span>][_mask], bins<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>linspace(<span style="color:#f92672">-</span><span style="color:#ae81ff">90</span>, <span style="color:#ae81ff">20</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1e-3</span>, <span style="color:#ae81ff">15</span>))
xc <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">*</span> (xe[:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> xe[<span style="color:#ae81ff">1</span>:])

dx <span style="color:#f92672">=</span> xe[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> xe[<span style="color:#ae81ff">0</span>]
H <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>log(gaussian_filter1d(H, sigma<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>) <span style="color:#f92672">/</span> dx <span style="color:#f92672">/</span> <span style="color:#ae81ff">4</span>)

fig, ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">4</span>), constrained_layout<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
ax<span style="color:#f92672">.</span>plot(xc, H)
ax<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;log-density&#34;</span>)
ax<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;$\phi_1$&#34;</span>)
</code></pre></div><pre><code>Text(0.5, 0, '$\\phi_1$')
</code></pre>
<p><img src="output_71_1.png" alt="png"></p>
<p>We again have to interpolate these values to the location of our model spline knots:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">init_ln_n0_bkg <span style="color:#f92672">=</span> sci<span style="color:#f92672">.</span>InterpolatedUnivariateSpline(xc, H)(StreamModel<span style="color:#f92672">.</span>bkg_knots)
</code></pre></div><p>Now we can package up our initial parameter estimates and try evaluating the <code>StreamModel.ln_density()</code> with this initial guess to see how well we did at estimating the properties of the stream.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">init_pars <span style="color:#f92672">=</span> {
    <span style="color:#e6db74">&#34;ln_n0&#34;</span>: init_ln_n0,
    <span style="color:#e6db74">&#34;mean_phi2&#34;</span>: init_mean_phi2,
    <span style="color:#e6db74">&#34;ln_std_phi2&#34;</span>: np<span style="color:#f92672">.</span>full_like(init_mean_phi2, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>),
    <span style="color:#e6db74">&#34;ln_n0_bkg&#34;</span>: init_ln_n0_bkg,
}
ln_dens_init <span style="color:#f92672">=</span> StreamModel<span style="color:#f92672">.</span>ln_density(
    StreamModel<span style="color:#f92672">.</span>integ_grid_phi1, StreamModel<span style="color:#f92672">.</span>integ_grid_phi2, <span style="color:#f92672">**</span>init_pars
)
</code></pre></div><p>We plot the initial guess of the full density distribution and over-plot the positions of the stars in our sample to see how well we did at setting initial guesses:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">fig, ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">3</span>), constrained_layout<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)

ax<span style="color:#f92672">.</span>plot(
    gd1_tbl[<span style="color:#e6db74">&#34;gd1_phi1&#34;</span>],
    gd1_tbl[<span style="color:#e6db74">&#34;gd1_phi2&#34;</span>],
    marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;o&#34;</span>,
    markeredgewidth<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,
    markersize<span style="color:#f92672">=</span><span style="color:#ae81ff">3.0</span>,
    ls<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;none&#34;</span>,
    alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.25</span>,
)
ax<span style="color:#f92672">.</span>pcolormesh(
    StreamModel<span style="color:#f92672">.</span>integ_grid_phi1,
    StreamModel<span style="color:#f92672">.</span>integ_grid_phi2,
    np<span style="color:#f92672">.</span>exp(ln_dens_init),
    cmap<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Blues&#34;</span>,
)
ax<span style="color:#f92672">.</span>set_xlim(<span style="color:#f92672">-</span><span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">20</span>)
ax<span style="color:#f92672">.</span>set_ylim(<span style="color:#f92672">-</span><span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">5</span>)

ax<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;$\phi_1$&#34;</span>)
ax<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;$\phi_2$&#34;</span>)
</code></pre></div><pre><code>Text(0, 0.5, '$\\phi_2$')
</code></pre>
<p><img src="output_77_1.png" alt="png"></p>
<p>That already looks pretty good, but clearly there are places where we hope the optimizer will tune the model parameters to align the track and width of the stream to the data we have. Let&rsquo;s get set up to run the optimizer from these initial parameter estimates:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">data <span style="color:#f92672">=</span> {
    <span style="color:#e6db74">&#34;phi1&#34;</span>: gd1_tbl[<span style="color:#e6db74">&#34;gd1_phi1&#34;</span>]<span style="color:#f92672">.</span>astype(np<span style="color:#f92672">.</span>float64),
    <span style="color:#e6db74">&#34;phi2&#34;</span>: gd1_tbl[<span style="color:#e6db74">&#34;gd1_phi2&#34;</span>]<span style="color:#f92672">.</span>astype(np<span style="color:#f92672">.</span>float64),
}
init_p <span style="color:#f92672">=</span> StreamModel<span style="color:#f92672">.</span>pack_pars(init_pars)
</code></pre></div><p>This is not necessary, but I always like to evaluate the objective function I want to optimize at the initial parameter values to make sure there are no nan or inf values that will cause the optimizer to immediately fail:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">StreamModel<span style="color:#f92672">.</span>objective(init_p, N<span style="color:#f92672">=</span>len(data[<span style="color:#e6db74">&#34;phi1&#34;</span>]), data<span style="color:#f92672">=</span>data)
</code></pre></div><pre><code>DeviceArray(-0.05543877, dtype=float64)
</code></pre>
<p>Good, that looks fine! Let&rsquo;s fire up the optimizer. We will again use the L-BFGS-B method:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">res <span style="color:#f92672">=</span> sco<span style="color:#f92672">.</span>minimize(
    jax<span style="color:#f92672">.</span>value_and_grad(StreamModel<span style="color:#f92672">.</span>objective),
    StreamModel<span style="color:#f92672">.</span>pack_pars(init_pars),
    args<span style="color:#f92672">=</span>(len(data[<span style="color:#e6db74">&#34;phi1&#34;</span>]), data),
    jac<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>,
    method<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;l-bfgs-b&#34;</span>,
    options<span style="color:#f92672">=</span>dict(maxiter<span style="color:#f92672">=</span><span style="color:#ae81ff">100_000</span>, maxls<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span>),
)
res
</code></pre></div><pre><code>      fun: -0.4172804414762403
 hess_inv: &lt;72x72 LbfgsInvHessProduct with dtype=float64&gt;
      jac: array([-7.71418475e-07,  1.65857911e-07,  1.99453381e-07, -2.05370143e-06,
       -1.70964779e-06, -4.62670967e-06,  1.68103189e-06,  2.09021076e-06,
       -1.10096842e-06,  2.27286148e-06, -1.52102203e-06, -1.37678490e-06,
       -2.28720309e-06, -2.26237554e-06, -1.30669594e-07, -3.37215730e-06,
       -1.02103330e-06,  8.87957954e-07,  2.43060947e-06,  4.48877098e-06,
        2.33454660e-06,  1.11753802e-06,  9.77205135e-07, -6.95522218e-07,
        1.15479706e-06, -1.69470906e-06,  1.78318820e-06, -1.94111769e-07,
       -5.52840315e-07, -7.36288750e-07, -8.92639157e-07,  1.55186650e-06,
       -1.59999460e-06, -3.26062519e-07,  3.79777447e-07,  3.28915248e-06,
       -7.19254555e-07, -3.63050574e-06, -1.34650105e-05, -1.33010540e-06,
        3.07614063e-05,  1.18970084e-05,  1.65802843e-05,  4.66520356e-06,
       -1.04483424e-06,  5.07504938e-07, -2.62358590e-06,  1.97680049e-07,
        1.39519635e-06, -5.60004049e-07,  2.91998158e-06, -3.85801945e-07,
        6.49247930e-07,  1.38578698e-06,  3.24259772e-06, -3.13469064e-06,
        1.89760659e-06, -3.11670312e-06,  6.85084618e-07, -8.07002305e-06,
       -2.91758878e-06,  3.64299264e-06, -2.47082774e-07,  1.81615140e-06,
        6.16494751e-07, -2.46474178e-07,  3.60654040e-06, -9.61968004e-08,
        3.94092601e-06,  3.81585532e-07, -8.09581201e-07,  1.17461144e-06])
  message: 'CONVERGENCE: REL_REDUCTION_OF_F_&lt;=_FACTR*EPSMCH'
     nfev: 470
      nit: 439
     njev: 470
   status: 0
  success: True
        x: array([-1.29724792, -1.29012651, -1.32220017, -1.01112565, -0.4372693 ,
        0.58312065,  1.56485491,  1.84623316,  1.86679529,  1.75244974,
        1.79167502,  2.39936208,  2.96517374,  3.28641774,  3.13259102,
        2.63325926,  2.72104495,  2.89475705,  2.89169773,  1.78894259,
        2.6488234 ,  3.05108255,  2.03688664,  2.74065293,  2.74767283,
        1.03251669,  0.73350755, -0.19425672, -0.36811195, -0.38745796,
       -0.38802526, -4.32570901, -4.29026727, -4.60164536, -2.65188131,
       -1.68654545, -1.0399299 , -0.49073281,  0.01935266,  0.15563387,
        0.07482995,  0.0315922 , -0.10760813, -0.75555268, -1.5350805 ,
       -1.82638106, -1.86999619, -1.86537359, -1.83413212, -1.86183605,
       -1.61951924, -0.98992293, -0.53122539, -0.83928341, -1.24429333,
       -1.24835943, -1.08013281, -1.86097141, -1.66590174, -1.82412536,
       -1.64303541, -1.32500325, -1.95722173, -1.62772084, -1.67305163,
       -2.76395382, -0.72947985, -0.56382768,  0.23704327,  0.85720292,
        0.13801779,  1.7967009 ])
</code></pre>
<p>It looks like that succeeded! Let&rsquo;s look at the optimized parameters:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">opt_pars <span style="color:#f92672">=</span> StreamModel<span style="color:#f92672">.</span>unpack_pars(res<span style="color:#f92672">.</span>x)
opt_pars
</code></pre></div><pre><code>{'ln_n0': DeviceArray([-1.29724792, -1.29012651, -1.32220017, -1.01112565,
              -0.4372693 ,  0.58312065,  1.56485491,  1.84623316,
               1.86679529,  1.75244974,  1.79167502,  2.39936208,
               2.96517374,  3.28641774,  3.13259102,  2.63325926,
               2.72104495,  2.89475705,  2.89169773,  1.78894259,
               2.6488234 ,  3.05108255,  2.03688664,  2.74065293,
               2.74767283,  1.03251669,  0.73350755, -0.19425672,
              -0.36811195, -0.38745796, -0.38802526], dtype=float64),
 'ln_n0_bkg': DeviceArray([-2.76395382, -0.72947985, -0.56382768,  0.23704327,
               0.85720292,  0.13801779,  1.7967009 ], dtype=float64),
 'ln_std_phi2': DeviceArray([-1.83413212, -1.86183605, -1.61951924, -0.98992293,
              -0.53122539, -0.83928341, -1.24429333, -1.24835943,
              -1.08013281, -1.86097141, -1.66590174, -1.82412536,
              -1.64303541, -1.32500325, -1.95722173, -1.62772084,
              -1.67305163], dtype=float64),
 'mean_phi2': DeviceArray([-4.32570901, -4.29026727, -4.60164536, -2.65188131,
              -1.68654545, -1.0399299 , -0.49073281,  0.01935266,
               0.15563387,  0.07482995,  0.0315922 , -0.10760813,
              -0.75555268, -1.5350805 , -1.82638106, -1.86999619,
              -1.86537359], dtype=float64)}
</code></pre>
<p>Again, it looks like there are no NaN or inf values, so that&rsquo;s good. Let&rsquo;s now compare the optimized parameters to our initial guesses:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">fig, axes <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">6</span>), sharex<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, constrained_layout<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
<span style="color:#66d9ef">for</span> ax, knots, name <span style="color:#f92672">in</span> zip(
    axes<span style="color:#f92672">.</span>flat,
    [
        StreamModel<span style="color:#f92672">.</span>ln_n0_knots,
        StreamModel<span style="color:#f92672">.</span>phi2_knots,
        StreamModel<span style="color:#f92672">.</span>phi2_knots,
        StreamModel<span style="color:#f92672">.</span>bkg_knots,
    ],
    [<span style="color:#e6db74">&#34;ln_n0&#34;</span>, <span style="color:#e6db74">&#34;mean_phi2&#34;</span>, <span style="color:#e6db74">&#34;ln_std_phi2&#34;</span>, <span style="color:#e6db74">&#34;ln_n0_bkg&#34;</span>],
):
    ax<span style="color:#f92672">.</span>plot(knots, init_pars[name], label<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;initial&#34;</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;#aaaaaa&#34;</span>, linewidth<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
    ax<span style="color:#f92672">.</span>plot(knots, opt_pars[name], label<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;optimized&#34;</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;k&#34;</span>)
    ax<span style="color:#f92672">.</span>set_title(name)

<span style="color:#66d9ef">for</span> ax <span style="color:#f92672">in</span> axes[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
    ax<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;$\phi_1$&#34;</span>)

ax<span style="color:#f92672">.</span>legend(loc<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;best&#34;</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">14</span>)
</code></pre></div><pre><code>&lt;matplotlib.legend.Legend at 0x7faeb1ef7a00&gt;



WARNING:matplotlib.font_manager:findfont: Font family ['serif'] not found. Falling back to DejaVu Sans.
WARNING:matplotlib.font_manager:findfont: Generic family 'serif' not found because none of the following families were found: Old Standard TT
</code></pre>
<p><img src="output_87_2.png" alt="png"></p>
<p>We can also look at the 2D density computed from our optimized parameters and visually compare to the data:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">ln_dens_opt <span style="color:#f92672">=</span> StreamModel<span style="color:#f92672">.</span>ln_density(
    StreamModel<span style="color:#f92672">.</span>integ_grid_phi1, StreamModel<span style="color:#f92672">.</span>integ_grid_phi2, <span style="color:#f92672">**</span>opt_pars
)
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">fig, axes <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(
    <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1</span>, figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">8</span>), sharex<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, sharey<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, constrained_layout<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>
)

<span style="color:#66d9ef">for</span> ax <span style="color:#f92672">in</span> [axes[<span style="color:#ae81ff">0</span>], axes[<span style="color:#ae81ff">2</span>]]:
    ax<span style="color:#f92672">.</span>plot(
        gd1_tbl[<span style="color:#e6db74">&#34;gd1_phi1&#34;</span>],
        gd1_tbl[<span style="color:#e6db74">&#34;gd1_phi2&#34;</span>],
        marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;o&#34;</span>,
        markeredgewidth<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,
        markersize<span style="color:#f92672">=</span><span style="color:#ae81ff">3.0</span>,
        ls<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;none&#34;</span>,
        alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.25</span>,
    )

ax <span style="color:#f92672">=</span> axes[<span style="color:#ae81ff">1</span>]
ax<span style="color:#f92672">.</span>pcolormesh(
    StreamModel<span style="color:#f92672">.</span>integ_grid_phi1,
    StreamModel<span style="color:#f92672">.</span>integ_grid_phi2,
    np<span style="color:#f92672">.</span>exp(ln_dens_opt),
    cmap<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Blues&#34;</span>,
)

ax <span style="color:#f92672">=</span> axes[<span style="color:#ae81ff">2</span>]
ax<span style="color:#f92672">.</span>pcolormesh(
    StreamModel<span style="color:#f92672">.</span>integ_grid_phi1,
    StreamModel<span style="color:#f92672">.</span>integ_grid_phi2,
    np<span style="color:#f92672">.</span>exp(ln_dens_opt),
    cmap<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Blues&#34;</span>,
)

ax<span style="color:#f92672">.</span>set_xlim(<span style="color:#f92672">-</span><span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">20</span>)
ax<span style="color:#f92672">.</span>set_ylim(<span style="color:#f92672">-</span><span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">5</span>)

axes[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;$\phi_1$&#34;</span>)
<span style="color:#66d9ef">for</span> ax <span style="color:#f92672">in</span> axes:
    ax<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;$\phi_2$&#34;</span>)
</code></pre></div><p><img src="output_90_0.png" alt="png"></p>
<p>This looks like a pretty good representation of the stream density and track, so I would call this a success! With the optimized parameters in hand, we could then run a sampler (like the HMC/NUTS sampler we used above) to generate posterior samples over our parameters and assess uncertainty in the model, or compute membership probabilities of belonging to the stream for the stars in this field. In a real application, we may also want to assess our choices by trying a few different settings for the number of spline knots for the different components of the model.</p>
<h1 id="recap">Recap</h1>
<p>This tutorial demonstrates how to use flexible, spline-based models in density functions with <a href="https://jax.readthedocs.io/">JAX</a>, which provides automatic calculation of gradients through our models and enables fast optimization and MCMC sampling methods even in cases like the above where the number of parameters is large.</p>
<p>If you have any comments or questions about this tutorial, please <a href="https://github.com/adrn-blog/post--flexible-density-model-jax/issues">open an issue on the GitHub repository for this post</a>. Thanks for reading!</p>

  </div>
</section>
<section id="tag-pane" class="meta">
  
  <div class="col-md-12">
    <h6 class="text-right meta">
      
    </h6>
  </div>
  
</section>








<section id="menu-pane" class="menu text-center">
  
  <h4 class="text-center"><a class="menu-item" href="https://adrian.pw/">home</a></h4>
</section>



<footer class="text-center footer">
  <hr />
  
  <h6 class="text-center copyright">© 2015-2022 Adrian Price-Whelan</h6>
  
  <h6 class="text-center extra-footer">Reach me at <a href="mailto:adrianmpw@gmail.com">adrianmpw@gmail.com</a></h6>
  
  
      
  
</footer>

</div>



<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  

<script type="text/javascript">
hljs.initHighlightingOnLoad();
</script>




<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-11936482-16', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="../../js/main.js"></script>
<script src="../../js/custom.js"></script>
</body>
</html>



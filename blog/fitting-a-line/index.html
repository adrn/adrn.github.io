<!DOCTYPE html>
<html lang="en-us">
<head>

<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="description" content="Simple minimalist theme">
<meta name="keywords" content="minimalist,blog,goa,hugo,developer">

<title>
  apw - Fitting a straight line to data 
</title>

<meta name="generator" content="Hugo 0.128.0">



<link rel="stylesheet" href="https://adrian.pw/css/github-syntax.css">


<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;1,300&family=Merriweather:wght@100;200;300;400;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css" integrity="sha384-DyZ88mC6Up2uqS4h/KRgHuoeGwBcD4Ng9SiP4dIRy0EXTlnuz47vAwmeGwVChigm" crossorigin="anonymous"/>
<link rel="stylesheet" href="https://adrian.pw/css/main.css">
<link rel="stylesheet" href="https://adrian.pw/css/custom.css">





<link rel="icon" type="image/png" href="../../img/favicon.ico" />


<link rel="manifest" href="../../manifest.json">

<meta name="theme-color" content="#ffffff">

</head>
<body lang="en-us">




<div class="wide-container">



<header class="text-left content-header">
  <h1 class="author"><a href="../../">Adrian Price-Whelan</a></h1>
</header>




<section id="menu-pane" class="menu text-center">
  
  <a class="menu-item" href="../../about/">about</a>
  
  <a class="menu-item" href="http://adrian.pw/cv/PriceWhelan-cv.pdf">cv</a>
  
  <a class="menu-item" href="../../blog/">blog</a>
  
  <a class="menu-item" href="../../research/">research</a>
  
  <a class="menu-item" href="../../viz/">visualizations</a>
  
</section>





<script>
    MathJax = {
      tex: {
        inlineMath: [
          ["$", "$"],
          ["\\(", "\\)"],
        ],
        displayMath: [
          ["$$", "$$"],
          ["\\[", "\\]"],
        ],
        processEscapes: true,
        processEnvironments: true,
      },
      options: {
        skipHtmlTags: ["script", "noscript", "style", "textarea", "pre"],
      },
    };

    
    
    
    
    
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
  ></script>


<section id="content-pane" class="">
  <div class="col-md-12 content">
    
      <h2 class="title">Fitting a straight line to data:</h1>
    

    <p class="meta">
      
        2018-06-15
      
    </p>

    <h1 id="fitting-a-straight-line-to-data">Fitting a straight line to data</h1>
<p>This notebook is a ~1 hour tutorial on fitting models to data, starting with a linear model and progressing to a linear model with an extra nonlinear parameter (an unknown extra variance to account for unknown error bars or intrinsic scatter).</p>
<p><em>This notebook is heavily inspired by <a href="https://arxiv.org/abs/1008.4686">Hogg et al. 2010</a>, <a href="https://github.com/jakevdp/ESAC-stats-2014">@jakevdp&rsquo;s notes</a>, and parts of the <a href="http://dan.iel.fm/emcee/current/user/line/">emcee documentation</a>.</em></p>
<p>Python imports we&rsquo;ll need later&hellip;</p>
<pre><code class="language-python">from IPython import display
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize

%matplotlib inline
rnd = np.random.RandomState(seed=42)
</code></pre>
<hr>
<h2 id="first-the-simpler-case-fitting-a-straight-line-to-data">First, the simpler case: fitting a straight line to data</h2>
<h3 id="intro-and-choice-of-objective-function">Intro and choice of objective function</h3>
<p>I want to start with a problem that might be familiar from undergraduate or high school lab courses. The problem is this: we observe <code>$N$</code> independent data points <code>$\boldsymbol{y}=\{y_1,y_2,...y_N\}$</code> with uncertainties <code>$\boldsymbol{\sigma}=\{\sigma_1,\sigma_2,...\sigma_N\}$</code> at perfectly-measured values <code>$\boldsymbol{x}=\{x_1,x_2,...x_N\}$</code>. For example, imagine the <code>$y$</code> are noisy velocity measurements, and the <code>$x$</code> are times (that can be measured very precisely). We have reason to believe that these data were generated by a process that is well-represented by a straight-line, and the only reason that the data deviate from this straight line is because of uncorrelated, Gaussian measurement noise in the <code>$y$</code>-direction. Let&rsquo;s first generate some data that meet these assumptions:</p>
<pre><code class="language-python">n_data = 16  # number of data points
a_true = 1.255  # randomly chosen truth
b_true = 4.507
</code></pre>
<pre><code class="language-python"># randomly generate some x values over some domain by sampling from a uniform distribution
x = rnd.uniform(0, 2.0, n_data)
x.sort()  # sort the values in place

# evaluate the true model at the given x values
y = a_true * x + b_true

# Heteroscedastic Gaussian uncertainties only in y direction
y_err = rnd.uniform(
    0.1, 0.2, size=n_data
)  # randomly generate uncertainty for each datum
y = rnd.normal(y, y_err)  # re-sample y data with noise
</code></pre>
<pre><code class="language-python">datastyle = dict(linestyle=&quot;none&quot;, marker=&quot;o&quot;, color=&quot;k&quot;, ecolor=&quot;#666666&quot;)
plt.errorbar(x, y, y_err, **datastyle)
plt.xlabel(&quot;$x$&quot;)
plt.ylabel(&quot;$y$&quot;)
plt.tight_layout()
</code></pre>
<p><img src="output_6_0.png" alt="png"></p>
<p>Now let&rsquo;s forget that we did that: let&rsquo;s pretend we don&rsquo;t know the truth, but that we think the true values of the data are well-described by a linear model. We would like to measure the &ldquo;best-fit&rdquo; parameters of this model (for a straight line, the slope and intercept <code>$(a,b)$</code>) given the data above. In math, our model for the data <code>$y$</code> is:</p>
<div>$$
\begin{align}
y &= f(x \,;\, a, b) + {\rm noise}\\
f(x \,;\, a, b) &= a\,x + b
\end{align}
$$</div>
<p>For a given set of parameters, <code>$(a,b)$</code>, we can evaluate our model <code>$f(x \,;\, a, b)$</code> at a given <code>$x$</code> location to compute the value of <code>$y$</code> that we would expect in the absence of noise. For example, for the <code>$n$</code>th datum and for a given set of parameter values <code>$(a,b)$</code>:</p>
<div>$$
\tilde{y}_n = f(x_n \,;\, a, b)
$$</div>
<p>We now want to search through all possible values of <code>$a,b$</code> to find the &ldquo;best&rdquo; values, given the data, with some definition of &ldquo;best.&rdquo; When we say this word, we are implying that we want to <em>optimize</em> (find the maximum or minimum) of some <em>objective function</em> (a function that takes our data, our model, and returns a quantification of &ldquo;best&rdquo;, usually as a scalar). Numerically, this scalar objective function can be any function (though you probably want it to be convex) and you will see different choices in practice. You have some leeway in this choice depending on whether your goal is <em>prediction</em>, <em>discovery</em>, <em>data compression</em>, or <em>discovery</em>.</p>
<p>However, for <em>inference</em>—the typical use-case for us as scientists—you don&rsquo;t have this freedom: one of the conclusions of this tutorial is going to be that <strong>you have no choice about what &ldquo;best&rdquo; means</strong>! Before we get there, though, let&rsquo;s explore what seem like reasonable choices.</p>
<p>Here are a few desirable features we&rsquo;d like any objective function to have:</p>
<ol>
<li>For a given set of parameters, we should compare our predicted values to the measured values and base our objective function on the differences</li>
<li>The scalar value should be dimensionless (the value of the objective function shouldn&rsquo;t care if we use kilometers vs. parsecs)</li>
<li>Data points that have larger errors should contribute less to the objective function (if a datum has a large offset from the predicted value, it shouldn&rsquo;t matter <em>if</em> the datum has a large uncertainty)</li>
<li>Convexity</li>
</ol>
<p>To meet these three criteria, whatever objective function we choose should operate on the (dimensionless) quantities:</p>
<div>$$
\chi_n = \frac{y_n - \tilde{y}_n}{\sigma_n}
$$</div>
<p>i.e. the difference between our predicted values <code>$\tilde{y}$</code> and the observed <code>$y$</code> values, weighted by the inverse uncertainties <code>$\sigma$</code>. The uncertainties have the same units as the data, so this is a dimensionless quantity. It also has the nice property that, as we wanted, points with large uncertainties are <em>downweighted</em> relative to points with small uncertainties. Here are some ideas for objective functions based on this scalar:</p>
<ul>
<li>
<p><strong>Weighted absolute deviation</strong>: the sum of the absolute values</p>
<p><code>$\sum_n^N \, \left|\chi_n\right|$</code></p>
</li>
<li>
<p><strong>Weighted squared deviation</strong>: the sum of the squares</p>
<p><code>$\sum_n^N \, \chi_n^2$</code></p>
</li>
<li>
<p><strong>Weighted absolute deviation to some power</strong> <code>$p$</code>:</p>
<p><code>$\sum_n^N \, \left|\chi_n\right|^p $</code></p>
</li>
</ul>
<p><em>(Note: don&rsquo;t show this to statisticians or they will get me fired. To a statistician, <code>$\chi^2$</code> is a distribution not a statistic&hellip;but astronomers seem to use this terminology.)</em></p>
<p>For simplicity, let&rsquo;s just compare two of these: the absolute deviation and the squared deviation. Both of these functions are convex and so we can pass them in to a naive optimizer to find the best parameters. Let&rsquo;s first implement the functions, and then pass them in to the default <code>scipy.optimize</code> function minimizer.</p>
<h3 id="exercise-1">Exercise 1:</h3>
<p>Implement the functions to compute the weighted absolute and squared deviations below</p>
<h4 id="solution">Solution:</h4>
<pre><code class="language-python">def line_model(pars, x):
    &quot;&quot;&quot;
    Evaluate a straight line model at the input x values.

    Parameters
    ----------
    pars : list, array
        This should be a length-2 array or list containing the
        parameter values (a, b) for the (slope, intercept).
    x : numeric, list, array
        The coordinate values.

    Returns
    -------
    y : array
        The computed y values at each input x.
    &quot;&quot;&quot;
    return pars[0] * np.array(x) + pars[1]


def weighted_absolute_deviation(pars, x, y, y_err):
    &quot;&quot;&quot;
    Compute the weighted absolute deviation between the data
    (x, y, y_err) and the model points computed with the input
    parameters (pars).
    &quot;&quot;&quot;
    chi = (y - line_model(pars, x)) / y_err
    return np.sum(np.abs(chi))


def weighted_squared_deviation(pars, x, y, y_err):
    &quot;&quot;&quot;
    Compute the weighted squared deviation between the data
    (x, y, y_err) and the model points computed with the input
    parameters (pars).
    &quot;&quot;&quot;
    chi = (y - line_model(pars, x)) / y_err
    return np.sum(chi**2)
</code></pre>
<p>We can demonstrate that these are convex (over some domain) by computing the objective function values over a grid of parameter values (a grid in <code>$a, b$</code>):</p>
<pre><code class="language-python"># make a 256x256 grid of parameter values centered on the true values
a_grid = np.linspace(a_true - 2.0, a_true + 2, 256)
b_grid = np.linspace(b_true - 2.0, b_true + 2, 256)
a_grid, b_grid = np.meshgrid(a_grid, b_grid)
ab_grid = np.vstack((a_grid.ravel(), b_grid.ravel())).T
</code></pre>
<pre><code class="language-python">fig, axes = plt.subplots(1, 2, figsize=(9, 5.1), sharex=True, sharey=True)

for i, func in enumerate([weighted_absolute_deviation, weighted_squared_deviation]):
    func_vals = np.zeros(ab_grid.shape[0])
    for j, pars in enumerate(ab_grid):
        func_vals[j] = func(pars, x, y, y_err)

    axes[i].pcolormesh(
        a_grid,
        b_grid,
        func_vals.reshape(a_grid.shape),
        cmap=&quot;Blues&quot;,
        vmin=func_vals.min(),
        vmax=func_vals.min() + 256,
    )  # arbitrary scale

    axes[i].set_xlabel(&quot;$a$&quot;)

    # plot the truth
    axes[i].plot(a_true, b_true, marker=&quot;o&quot;, zorder=10, color=&quot;tab:red&quot;)
    axes[i].axis(&quot;tight&quot;)
    axes[i].set_title(func.__name__, fontsize=14)

axes[0].set_ylabel(&quot;$b$&quot;)

fig.tight_layout()
</code></pre>
<p><img src="output_11_0.png" alt="png"></p>
<p>There are minima in both cases near the true values of the parameters (good), but the gradient of the function is clearly different (the color scales are the same in each panel above). Let&rsquo;s see what happens when we minimize these objective functions to get the best-fit parameter values:</p>
<pre><code class="language-python">x0 = [1.0, 1.0]  # starting guess for the optimizer

result_abs = minimize(
    weighted_absolute_deviation,
    x0=x0,
    args=(x, y, y_err),  # passed to the weighted_*_deviation function after pars
    method=&quot;BFGS&quot;,
)  # similar to Newton's method

result_sq = minimize(
    weighted_squared_deviation,
    x0=x0,
    args=(x, y, y_err),  # passed to the weighted_*_deviation function after pars
    method=&quot;BFGS&quot;,
)

best_pars_abs = result_abs.x
best_pars_sq = result_sq.x
</code></pre>
<p>Let&rsquo;s now plot our two best-fit lines over the data:</p>
<pre><code class="language-python">plt.errorbar(x, y, y_err, linestyle=&quot;none&quot;, marker=&quot;o&quot;, ecolor=&quot;#666666&quot;)

x_grid = np.linspace(x.min() - 0.1, x.max() + 0.1, 128)
plt.plot(
    x_grid,
    line_model(best_pars_abs, x_grid),
    marker=&quot;&quot;,
    linestyle=&quot;-&quot;,
    label=&quot;absolute deviation&quot;,
)
plt.plot(
    x_grid,
    line_model(best_pars_sq, x_grid),
    marker=&quot;&quot;,
    linestyle=&quot;-&quot;,
    label=&quot;squared deviation&quot;,
)

plt.xlabel(&quot;$x$&quot;)
plt.ylabel(&quot;$y$&quot;)

plt.legend(loc=&quot;best&quot;)
plt.tight_layout()
</code></pre>
<p><img src="output_15_0.png" alt="png"></p>
<p>Well, by eye they both look reasonable! Are we done?! Not quite &ndash; how do we choose between the two?!</p>
<p>In order to pick between these two, or any of the arbitrary objective functions we could have chosen, we have to <em>justify</em> using one function over the others. In what follows, we&rsquo;ll justify optimizing the sum of the squared deviations (so-called &ldquo;least-squares fitting&rdquo;) by thinking about the problem <em>probabilistically</em>, rather than procedurally.</p>
<h3 id="least-squares-fitting">Least-squares fitting</h3>
<p>Let&rsquo;s review the assumptions we made above in generating our data:</p>
<ol>
<li>The data were generated by a straight line</li>
<li>Uncorrelated, <em>known</em> Gaussian uncertainties in <code>$y$</code> cause deviations between the data and predictions</li>
<li>The data points are independent</li>
<li>The <code>$x$</code> data are known perfectly, or at least their uncertainties are <em>far smaller</em> than the uncertainties in <code>$y$</code></li>
</ol>
<p>First off, these assumptions tell us that for each datum <code>$(x_n, y_n)$</code> there is some true <code>$y_{n,{\rm true}}$</code>, and because of limitations in our observing process we can&rsquo;t observe the truth, but we know that the values we do observe will be Gaussian (Normal) distributed around the true value. <em>(Note: This assumption tends to be a good or at least a conservative approximation in practice, but there are certainly more complex situations when, e.g., you have asymmetric uncertainties, or error distributions with large tails!)</em>. In math:</p>
<div>$$
\begin{align}
p(y \,|\, y_{\rm true}) &= \mathcal{N}(y \,|\, y_{\rm true}, \sigma^2) \\
\mathcal{N}(y \,|\, y_{\rm true}, \sigma^2) &= (2\pi \sigma^2)^{-1/2} \, \exp\left(-\frac{1}{2} \frac{(y-y_{\rm true})^2}{\sigma^2} \right)
\end{align}
$$</div>
<p>This is the likelihood of observing a particular <code>$y$</code> given the true <code>$y_{\rm true}$</code>. Note that in our model, all of the <code>$y_{\rm true}$</code>&rsquo;s must lie on a line. It is also interesting that the argument of the normal distribution looks a lot like <code>$\chi^2$</code>!</p>
<p>What about considering two data points, <code>$y_1$</code> and <code>$y_2$</code>? Now we need to write down the <em>joint</em> probability</p>
<div>$$
p(y_1, y_2 \,|\, y_{1,{\rm true}}, \sigma_1, y_{2,{\rm true}}, \sigma_2)
$$</div>
<p>But, note that in assumption 3 above, we are assuming the data are independent. In that case, the random error in one point does not affect the random error in any other point, so the joint probability can be turned into a product:</p>
<div>$$
p(\{y_n\} \,|\, \{y_{n,{\rm true}}\}, \{\sigma_n\}) = \prod_n^N \, p(y_n \,|\, y_{n,{\rm true}}, \sigma_n)
$$</div>
<p>This is the full expression for the likelihood of the observed data given the true <code>$y$</code> values. Recall that these true values, according to our assumptions, must lie on a line with some parameters, and we&rsquo;re trying to infer those parameters! We can compute a particular <code>$y_{n,{\rm true}}$</code> using <code>$x_n$</code> and a given set of model parameters <code>$a, b$</code>. With that in mind, we can write the likelihood instead as:</p>
<div>$$
p(\{y_n\} \,|\, a, b, \{x_n\}, \{\sigma_n\}) = \prod_n^N \, p(y_n \,|\, a, b, x_n, \sigma_n)
$$</div>
<p>So what are the &ldquo;best&rdquo; values of the parameters <code>$a, b$</code>? They are the ones that <em>maximize</em> this likelihood!</p>
<p>The product on the right of the likelihood is a product over exponentials (well, Gaussians), which can be annoying to deal with. But, maximizing the likelihood is equivalent to maximizing the <em>log</em>-likelihood &ndash; so we can get rid of the product and all of those exponentials by taking the log of both sides:</p>
<div>$$
\begin{align}
\ln p(\{y_n\} \,|\, a, b, \{x_n\}, \{\sigma_n\}) &= \sum_n^N \, \ln\left[p(y_n \,|\, a, b, x_n, \sigma_n)\right] \\
&= \sum_n^N \ln \left[(2\pi \sigma_n^2)^{-1/2} \, 
    \exp\left(-\frac{1}{2} \frac{(y_n-(a\,x_n+b))^2}{\sigma_n^2} \right) \right] \\
&= -\frac{N}{2}\ln(2\pi) 
    - \frac{1}{2} \sum_n^N \left[\frac{(y_n-(a\,x_n+b))^2}{\sigma_n^2} + \ln{\sigma_n^2} \right]
\end{align}
$$</div>
<p>In this case, the uncertainties are known and constant, so to maximize this expression we only care that (abbreviating the likelihood as <code>$\mathcal{L}$</code>):</p>
<div>$$
\begin{align}
\ln \mathcal{L} &= - \frac{1}{2} \sum_n^N \left[\frac{(y_n-(a\,x_n+b))^2}{\sigma_n^2}\right] + {\rm const.} \\
&= - \frac{1}{2} \sum_n^N \, \chi_n^2 + {\rm const.} \\
\end{align}
$$</div>
<p>Apparently, <em>minimizing</em> the sum of the weighted squared deviations is equivalent to <em>maximizing</em> the (log) likelihood derived from thinking about the probability of the data! Above, we did that minimization numerically using an iterative solver. That&rsquo;s fine, but (a) it doesn&rsquo;t directly give us the uncertainties on the inferred model parameters, and (b) there is actually an analytic way to solve this problem using linear algebra that is generally <em>much</em> faster!</p>
<h3 id="least-squares--maximum-likelihood-with-matrix-calculus">Least-squares / maximum likelihood with matrix calculus</h3>
<p>Using linear algebra, we can simplify and generalize a lot of the expressions above. In what follows, all vectors are column vectors and are represented by lower-case bold symbols. Matrices are upper-case bold symbols.</p>
<p>We&rsquo;ll start by writing our model as a matrix equation. To do that, we need a way to, for a given set of parameters, compute the set of predicted <code>$y$</code>&rsquo;s. This is done by defining the parameter vector, <code>$\boldsymbol{\theta}$</code>, and a matrix typically called the <em>design matrix</em>, <code>$\boldsymbol{X}$</code>:</p>
<div>$$
\boldsymbol{\theta} = \begin{bmatrix} b \\ a \end{bmatrix} \quad 
\boldsymbol{X} = \begin{bmatrix} 1 & x_1 \\ 1 & x_2 \\ \vdots & \vdots \\ 1 & x_N \end{bmatrix}
$$</div>
<p>(note the order of the parameters!). With these definitions, the vector of predicted <code>$y$</code> values is just</p>
<div>$$
\boldsymbol{y}_{\rm pred} = \boldsymbol{X} \, \boldsymbol{\theta}
$$</div>
<p>so the deviation vector between the prediction and the data is just <code>$(\boldsymbol{y}-\boldsymbol{X} \, \boldsymbol{\theta})$</code> where</p>
<div>$$
\boldsymbol{y} = \begin{bmatrix} y_1 \\ y_2 \\ \vdots \\ y_N \end{bmatrix}
$$</div>
<p>But how do we include the uncertainties? We&rsquo;ll pack the list of uncertainties (variances) into the trace of a 2D, <code>$N \times N$</code> matrix called the <em>covariance matrix</em>. Because we are assuming the uncertainties are independent, the off-diagonal terms are all zero:</p>
<div>$$
\boldsymbol{\Sigma} = \begin{bmatrix} 
\sigma_1^2 & 0 & \dots & 0 \\ 
0 & \sigma_2^2 & \dots & 0 \\ 
\vdots & \vdots & \ddots & \vdots \\
0 & 0 & 0 & \sigma_N^2 
\end{bmatrix}
$$</div>
<p>With these matrices, we can write the expression for <code>$\chi^2$</code> (and therefore the log-likelihood) very concisely:</p>
<div>$$
\begin{align}
\chi^2 &= \left(\boldsymbol{y} - \boldsymbol{X}\,\boldsymbol{\theta}\right)^\mathsf{T} \, 
    \boldsymbol{\Sigma}^{-1} \,
    \left(\boldsymbol{y} - \boldsymbol{X}\,\boldsymbol{\theta}\right) \\
\ln\mathcal{L} &= -\frac{1}{2}\left[N\,\ln(2\pi) 
    + \ln|\boldsymbol{\Sigma}|
    + \left(\boldsymbol{y} - \boldsymbol{X}\,\boldsymbol{\theta}\right)^\mathsf{T} \, 
      \boldsymbol{\Sigma}^{-1} \,
      \left(\boldsymbol{y} - \boldsymbol{X}\,\boldsymbol{\theta}\right)
\right]
\end{align}
$$</div>
<p>In this form, the terms in the <code>$\chi^2$</code> have a nice geometric interpretation: This looks like a distance between the data and the model computed with the metric <code>$\boldsymbol{\Sigma}$</code>.</p>
<p>If you solve for the optimum of the log-likelihood function (take the derivative with respect to <code>$\boldsymbol{\theta}$</code> and set equal to 0), you find that:</p>
<div>$$
\newcommand{\trpo}[1]{{#1}^{\mathsf{T}}}
\newcommand{\bs}[1]{\boldsymbol{#1}}
\bs{\theta}_{\rm best} = \left[\trpo{\bs{X}} \, \bs{\Sigma}^{-1} \, \bs{X}\right]^{-1} \, 
    \trpo{\bs{X}} \, \bs{\Sigma}^{-1} \, \bs{y}
$$</div>
<p>Getting the best-fit parameters just requires a few simple linear algebra operations! As an added bonus, we also get the <em>uncertainties</em> on the parameters. The <code>$2\times2$</code> covariance matrix for the best-fit parameters is given by the matrix:</p>
<div>$$
\newcommand{\trpo}[1]{{#1}^{\mathsf{T}}}
\newcommand{\bs}[1]{\boldsymbol{#1}}
C = \left[\trpo{\bs{X}} \, \bs{\Sigma}^{-1} \, \bs{X}\right]^{-1}
$$</div>
<p>Instead of using an iterative optimizer like <code>scipy.optimize.minimize</code>, let&rsquo;s just write out the linear algebra explicitly and use <code>numpy.linalg</code> to solve this for us!</p>
<h3 id="exercise-2">Exercise 2:</h3>
<p>Implement the necessary linear algebra to solve for the best-fit parameters and the parameter covariance matrix, defined above.</p>
<h4 id="solution-1">Solution:</h4>
<pre><code class="language-python"># create matrices and vectors:

# learn this is a magical function - it makes exactly what we want for the design matrix
X = np.vander(x, N=2, increasing=True)

# you never want to do this in practice because the matrix will just be full of zeros!
#   that's a good way to waste all of your RAM on storing zeros...
Cov = np.diag(y_err**2)
Cinv = np.linalg.inv(Cov)  # we need the inverse covariance matrix

X.shape, Cov.shape, y.shape
</code></pre>
<pre><code>((16, 2), (16, 16), (16,))
</code></pre>
<pre><code class="language-python"># using the new Python matrix operator
best_pars_linalg = np.linalg.inv(X.T @ Cinv @ X) @ (X.T @ Cinv @ y)

# we can also get the parameter covariance matrix
pars_Cov = np.linalg.inv(X.T @ Cinv @ X)
</code></pre>
<p>Let&rsquo;s see how the parameter values compare to what we found using the numerical optimizer (we reversed the order for the linear algebra so we use <code>[::-1]</code> to reverse the array):</p>
<pre><code class="language-python">best_pars_sq - best_pars_linalg[::-1]
</code></pre>
<pre><code>array([-1.13359355e-08,  3.98420585e-09])
</code></pre>
<p>They are almost identical! That&rsquo;s good. Now let&rsquo;s look at the covariance matrix of the parameters (the uncertainty in the parameters) and plot the 1 and 2-sigma error ellipses:</p>
<pre><code class="language-python"># some tricks to get info we need to plot an ellipse, aligned with
#    the eigenvectors of the covariance matrix
eigval, eigvec = np.linalg.eig(pars_Cov)
angle = np.degrees(np.arctan2(eigvec[1, 0], eigvec[0, 0]))
w, h = 2 * np.sqrt(eigval)
</code></pre>
<pre><code class="language-python">from matplotlib.patches import Ellipse

fig, ax = plt.subplots(1, 1, figsize=(5, 5))

for n in [1, 2]:
    ax.add_patch(
        Ellipse(
            best_pars_linalg,
            width=n * w,
            height=n * h,
            angle=angle,
            fill=False,
            linewidth=3 - n,
            edgecolor=&quot;#555555&quot;,
            label=r&quot;{}$\sigma$&quot;.format(n),
        )
    )

ax.plot(
    b_true,
    a_true,
    marker=&quot;o&quot;,
    zorder=10,
    linestyle=&quot;none&quot;,
    color=&quot;#de2d26&quot;,
    label=&quot;truth&quot;,
)

ax.set_xlabel(&quot;$b$&quot;)
ax.set_ylabel(&quot;$a$&quot;)
ax.legend(loc=&quot;best&quot;)

fig.tight_layout()
</code></pre>
<p><img src="output_27_0.png" alt="png"></p>
<h2 id="the-bayesian-approach">The Bayesian approach</h2>
<p>Let&rsquo;s review what we did so far. We found that standard weighted least squares fitting is a justified approach to estimating the best-fit parameters because it optimizes the likelihood of the data under the assumptions of our model; it optimizes a <em>justified scalar objective function</em>. We then fit our straight-line model to the data using and got back a point-estimate of the best parameters along with a covariance matrix describing the uncertainties in the parameters. This is the way of the <em>frequentist</em>. What we&rsquo;re going to do now is see what happens if we switch to a Bayesian methodology instead. While the two methods end up looking mathematically identical, there are fundamental philosophical differences that can lead to very different interpretations and implementations when models are more complex than the toy example we use above.</p>
<p>As Bayesians, we aren&rsquo;t interested in a point-estimate of the best parameters, but rather we&rsquo;re interested in the inferred distribution of possible parameter values (the <em>posterior probability distribution function</em> over parameters). So how do we write down or solve for this posterior pdf? Before we get to that, let&rsquo;s take a look at a fundamental equation of Bayesian statistics, <a href="https://en.wikipedia.org/wiki/Bayes'_theorem">Bayes&rsquo; theorem</a>, which we&rsquo;ll derive using the joint probability of <code>$A$</code> and <code>$B$</code> which are conditional on some other information <code>$I$</code> that, right now, we don&rsquo;t care about. For example, <code>$A$</code> could be the time it takes to get from here to NYC, <code>$B$</code> could be the amount of traffic on the road, and <code>$I$</code> could include the information that we&rsquo;re driving a car and not walking. Bayes&rsquo; theorem as expressed below is not controversial &ndash; Bayesians and Frequentists agree that this is just how joint and conditional probabilities work. We start by writing down the joint probability of <code>$A$</code> and <code>$B$</code>, then factor it in two ways into conditional proabilities:</p>
<div>$$
p(A,B \,|\, I) = p(A\,|\,B, I)\,p(B\,|\, I) = p(B\,|\,A, I)\,p(A \,|\, I)
$$</div>
<p>Now we look at the right two expressions, and divide by one of the marginal probabilities to get:</p>
<div>$$
p(A\,|\,B, I) = \frac{p(B\,|\,A, I)\,p(A \,|\, I)}{p(B\,|\, I)}
$$</div>
<p>Ok, so that&rsquo;s all fine. Now let&rsquo;s replace <code>$A$</code> and <code>$B$</code> with variables that represent, from our example above, our data <code>$D=(\{x_n\},\{y_n\},\{\sigma_n\})$</code> and our model parameters <code>$\boldsymbol{\theta}$</code>:</p>
<div>$$
p(\boldsymbol{\theta}\,|\,D, I) = \frac{p(D\,|\,\boldsymbol{\theta}, I)\,p(\boldsymbol{\theta} \,|\, I)}{p(D\,|\, I)}
$$</div>
<p>In just switching the meaning of the variables, this expression becomes controversial! Frequentists would object to the above for two main reasons:</p>
<ol>
<li>The term on the left hand side is a probability over parameters given the data (the <em>posterior</em> pdf) <code>$p(\boldsymbol{\theta}\,|\,D, I)$</code>. This is something that a frequentist would say cannot exist - there is only one true vector of parameters that we are trying to learn, not a distribution!</li>
<li>The right-most term in the numerator is a probability over parameters <em>with no dependence on the data</em> (the <em>prior</em> pdf). This encapsulates all of our prior knowledge about the parameters before we did the experiment and observed some data. This is perhaps the aspect of Bayesian inference that frequentists most disagree with.</li>
</ol>
<p>The differences above result from the fact that probability means something different to Frequentists and Bayesians. Bayesians think of probability as representing a <em>degree of belief</em> about something, whereas a frequentist thinks of a probability as related to <em>limiting frequencies of occurrence</em> in repeated trials or observations. This is a rich topic and I highly recommend reading <a href="http://jakevdp.github.io/blog/2014/03/11/frequentism-and-bayesianism-a-practical-intro/">this series of blogposts</a> by Jake Vanderplas to learn more. For now, let&rsquo;s put on Bayesian hats and take a look at the implications of the expression above.</p>
<p>(<em>It&rsquo;s good to rememeber that we&rsquo;re all friends. The differences are based on philosophy and so can lead to some heated discussions and debates, but remember we&rsquo;re all trying to do science &ndash; we&rsquo;re on the same team!</em>)</p>
<h2 id="bayes-theorem-and-bayesian-inference">Bayes&rsquo; theorem and Bayesian inference</h2>
<p>Let&rsquo;s decompose Bayes&rsquo; theorem (as applied to modeling and inference). The four terms in Bayes&rsquo; theorem above have names that are good to be familiar with:</p>
<ul>
<li>
<p><code>$p(\boldsymbol{\theta}\,|\,D, I)$</code> - <strong>posterior probability</strong>:
This is the thing we are after when we do Bayesian inference or model fitting. We want to know what the distribution of possible parameter values is, given the data we observe and any prior information or assumptions <code>$I$</code>.</p>
</li>
<li>
<p><code>$p(D\,|\,\boldsymbol{\theta}, I)$</code> - <strong>likelihood</strong>:
This is the likelihood of the data given a particular set of model parameters. We&rsquo;ve already seen this object and used it above to find the best-fit model parameters by maximizing this function. In a Bayesian context, it can also be thought of as a distribution &ndash; it&rsquo;s a distribution that generates new datasets given a model instance. For that reason, we typically refer to models that produce a likelihood as <em>generative models</em> because they specify how to  generate new data sets that look like the one you observe. As we saw above when we wrote the likelihood function for a straight line model and data with Gaussian errors, the likelihood usually contains a component that can be interpreted as the <em>noise model</em>.</p>
</li>
<li>
<p><code>$p(\boldsymbol{\theta} \,|\, I)$</code> - <strong>prior probability</strong>
This contains any relevant information about our parameters that we know before observing the data. This can include physical constraints, previous measurements, or anything, really. This flexibility is what makes the prior a somewhat controversial object. In practice, the prior only really matters if it is much narrower than the likelihood function. If the prior is broad with respect to the likelihood, the information in the likelihood makes the prior almost irrelevant. However, there are several subtleties to choosing priors that need to be considered. As an example, one subtlety comes from the choice of coordinates for the model parameters: a prior that is broad and flat in a parameter <code>$\alpha$</code> won&rsquo;t be broad and flat if you change variables to <code>$\beta = \alpha^2$</code>.</p>
</li>
<li>
<p><code>$p(D\,|\, I)$</code> - <strong>evidence</strong> or <strong>fully marginalized likelihood</strong> (FML)
In many cases the evidence is simply a normalization constant and, for some of the most relevant algorithms used in inference, can be ignored. This term involves an integral over all of parameter space that can be very difficult to compute:</p>
  <div>$$
  p(D\,|\, I) = \int \,\mathrm{d}\boldsymbol{\theta} \, p(D\,|\,\boldsymbol{\theta}, I) \, p(\boldsymbol{\theta} \,|\, I)
  $$</div>
<p>If you need to do Bayesian model selection (e.g., decide between models with different parameters), you unfortunately need to compute this quantity. But if you only <em>think</em> you need the FML, beware!</p>
</li>
</ul>
<p>So how do we make use of all of this, in practice?</p>
<p>Let&rsquo;s return to our example of fitting a line to data with the same data as above. In some sense, we are almost done once we write down an expression for the posterior pdf. If we ignore the FML, this amounts to multiplying a likelihood by a prior pdf. Well, we&rsquo;ve already done the most important part: we already wrote down the likelihood function! This is often the hardest part and what we spend the most time doing as scientists (well, assuming you&rsquo;re not building the instrument to observe the data!). We now need to define a prior pdf over the model parameters. Here we have some flexibility. Two possibilities you can always consider:</p>
<ol>
<li>A completely uninformative prior, based on dimensionality, symmetry, or entropy arguments (sometimes, this will mean using a <em>flat prior</em> or <em>uniform prior</em>)</li>
<li>An empirical prior, based on previous <em>independent data</em> that constrains this model (e.g., a previous measurement of the model parameters from an earlier dataset)</li>
</ol>
<p>For simplicity, we&rsquo;re going to assume a flat prior over both slope and intercept. Note that for this problem, this is <a href="http://jakevdp.github.io/blog/2014/06/14/frequentism-and-bayesianism-4-bayesian-in-python/"><em>not</em> an uninformative prior</a>. For now, we&rsquo;ll assume that the data are informative enough that the small bias we introduce by using this prior is negligible. Let&rsquo;s now define the functions we&rsquo;ll need, and recall that</p>
<div>$$
\ln\mathcal{L} = -\frac{1}{2}\left[N\,\ln(2\pi) 
    + \ln|\boldsymbol{\Sigma}|
    + \left(\boldsymbol{y} - \boldsymbol{X}\,\boldsymbol{\theta}\right)^\mathsf{T} \, 
      \boldsymbol{\Sigma}^{-1} \,
      \left(\boldsymbol{y} - \boldsymbol{X}\,\boldsymbol{\theta}\right)
\right]
$$</div>
<h3 id="exercise-3">Exercise 3:</h3>
<p>Implement the log-prior method (<code>ln_prior</code>) on the model class below.</p>
<h4 id="solution-2">Solution:</h4>
<pre><code class="language-python">class StraightLineModel(object):
    def __init__(self, x, y, y_err):
        &quot;&quot;&quot;
        We store the data as attributes of the object so we don't have to
        keep passing it in to the methods that compute the probabilities.
        &quot;&quot;&quot;
        self.x = np.asarray(x)
        self.y = np.asarray(y)
        self.y_err = np.asarray(y_err)

    def ln_likelihood(self, pars):
        &quot;&quot;&quot;
        We don't need to pass in the data because we can access it from the
        attributes. This is basically the same as the weighted squared
        deviation function, but includes the constant normalizations for the
        Gaussian likelihood.
        &quot;&quot;&quot;
        N = len(self.y)
        dy = self.y - line_model(pars, self.x)
        ivar = 1 / self.y_err**2  # inverse-variance
        return -0.5 * (
            N * np.log(2 * np.pi)
            + np.sum(2 * np.log(self.y_err))
            + np.sum(dy**2 * ivar)
        )

    def ln_prior(self, pars):
        &quot;&quot;&quot;
        The prior only depends on the parameters, so we don't need to touch
        the data at all. We're going to implement a flat (uniform) prior
        over the ranges:
            a : [0, 100]
            b : [-50, 50]

        &quot;&quot;&quot;

        a, b = pars  # unpack parameters
        ln_prior_val = 0.0  # we'll add to this

        if a &lt; 0 or a &gt; 100.0:
            return -np.inf
        else:
            ln_prior_val += np.log(1e-2)  # normalization, log(1/100)

        if b &lt; -50 or b &gt; 50.0:
            return -np.inf
        else:
            ln_prior_val += np.log(1e-2)  # normalization, log(1/100)

        return ln_prior_val

    def ln_posterior(self, pars):
        &quot;&quot;&quot;
        Up to a normalization constant, the log of the posterior pdf is just
        the sum of the log likelihood plus the log prior.
        &quot;&quot;&quot;
        lnp = self.ln_prior(pars)
        if np.isinf(
            lnp
        ):  # short-circuit if the prior is infinite (don't bother computing likelihood)
            return lnp

        lnL = self.ln_likelihood(pars)
        lnprob = lnp + lnL

        if np.isnan(lnprob):
            return -np.inf

        return lnprob

    def __call__(self, pars):
        return self.ln_posterior(pars)
</code></pre>
<pre><code class="language-python">model = StraightLineModel(x, y, y_err)
</code></pre>
<p>Now we&rsquo;ll repeat what we did above to map out the value of the log-posterior over a 2D grid of parameter values. Because we used a flat prior, you&rsquo;ll notice it looks identical to the visualization of the <code>weighted_squared_deviation</code> &ndash; only the likelihood has any slope to it!</p>
<pre><code class="language-python">def evaluate_on_grid(func, a_grid, b_grid, args=()):
    a_grid, b_grid = np.meshgrid(a_grid, b_grid)
    ab_grid = np.vstack((a_grid.ravel(), b_grid.ravel())).T

    func_vals = np.zeros(ab_grid.shape[0])
    for j, pars in enumerate(ab_grid):
        func_vals[j] = func(pars, *args)

    return func_vals.reshape(a_grid.shape)
</code></pre>
<pre><code class="language-python">fig, axes = plt.subplots(1, 3, figsize=(14, 5.1), sharex=True, sharey=True)

# make a 256x256 grid of parameter values centered on the true values
a_grid = np.linspace(a_true - 5.0, a_true + 5, 256)
b_grid = np.linspace(b_true - 5.0, b_true + 5, 256)

ln_prior_vals = evaluate_on_grid(model.ln_prior, a_grid, b_grid)
ln_like_vals = evaluate_on_grid(model.ln_likelihood, a_grid, b_grid)
ln_post_vals = evaluate_on_grid(model.ln_posterior, a_grid, b_grid)

for i, vals in enumerate([ln_prior_vals, ln_like_vals, ln_post_vals]):
    axes[i].pcolormesh(
        a_grid, b_grid, vals, cmap=&quot;Blues&quot;, vmin=vals.max() - 1024, vmax=vals.max()
    )  # arbitrary scale

axes[0].set_title(&quot;log-prior&quot;, fontsize=20)
axes[1].set_title(&quot;log-likelihood&quot;, fontsize=20)
axes[2].set_title(&quot;log-posterior&quot;, fontsize=20)

for ax in axes:
    ax.set_xlabel(&quot;$a$&quot;)

    # plot the truth
    ax.plot(a_true, b_true, marker=&quot;o&quot;, zorder=10, color=&quot;#de2d26&quot;)
    ax.axis(&quot;tight&quot;)

axes[0].set_ylabel(&quot;$b$&quot;)

fig.tight_layout()
</code></pre>
<p><img src="output_35_0.png" alt="png"></p>
<h3 id="exercise-4">Exercise 4:</h3>
<p>Subclass the <code>StraightLineModel</code> class and implement a new prior. Replace the flat prior above with an uncorrelated 2D Gaussian centered on <code>$(\mu_a,\mu_b) = (3., 5.5)$</code> with root-variances <code>$(\sigma_a,\sigma_b) = (0.05, 0.05)$</code>. Compare the 2D grid plot with the flat prior to the one with a Gaussian prior</p>
<h4 id="solution-3">Solution:</h4>
<pre><code class="language-python">class StraightLineModelGaussianPrior(
    StraightLineModel
):  # verbose names are a good thing!
    def ln_prior(self, pars):
        a, b = pars  # unpack parameters
        ln_prior_val = 0.0  # we'll add to this

        # prior on a is a Gaussian with mean, stddev = (3, 0.05)
        ln_prior_val += (
            -0.5 * (a - 3.0) ** 2 / 0.05**2
        )  # this is not normalized properly, but that's ok

        # prior on b is a Gaussian with mean, stddev = (5.5, 0.05)
        ln_prior_val += (
            -0.5 * (b - 5.5) ** 2 / 0.05**2
        )  # this is not normalized properly, but that's ok

        return ln_prior_val
</code></pre>
<pre><code class="language-python">model_Gprior = StraightLineModelGaussianPrior(x, y, y_err)
</code></pre>
<pre><code class="language-python">fig, axes = plt.subplots(1, 3, figsize=(14, 5.1), sharex=True, sharey=True)

ln_prior_vals2 = evaluate_on_grid(model_Gprior.ln_prior, a_grid, b_grid)
ln_like_vals2 = evaluate_on_grid(model_Gprior.ln_likelihood, a_grid, b_grid)
ln_post_vals2 = evaluate_on_grid(model_Gprior.ln_posterior, a_grid, b_grid)

for i, vals in enumerate([ln_prior_vals2, ln_like_vals2, ln_post_vals2]):
    axes[i].pcolormesh(
        a_grid, b_grid, vals, cmap=&quot;Blues&quot;, vmin=vals.max() - 1024, vmax=vals.max()
    )  # arbitrary scale

axes[0].set_title(&quot;log-prior&quot;, fontsize=20)
axes[1].set_title(&quot;log-likelihood&quot;, fontsize=20)
axes[2].set_title(&quot;log-posterior&quot;, fontsize=20)

for ax in axes:
    ax.set_xlabel(&quot;$a$&quot;)

    # plot the truth
    ax.plot(a_true, b_true, marker=&quot;o&quot;, zorder=10, color=&quot;#de2d26&quot;)
    ax.axis(&quot;tight&quot;)

axes[0].set_ylabel(&quot;$b$&quot;)

fig.tight_layout()
</code></pre>
<p><img src="output_39_0.png" alt="png"></p>
<hr>
<p>Now what do we do? The answer depends a bit on your intentions. If you&rsquo;d like to propagate the posterior pdf (as in, pass on to other scientists to use your results), what do you do if the posterior pdf isn&rsquo;t analytic? And what numbers do you put in your abstract? One option is to draw samples from your posterior pdf and compute summary statistics (e.g., median and quantils) using the samples. That&rsquo;s the approach we&rsquo;re going to take.</p>
<h2 id="mcmc">MCMC</h2>
<p>One of the most common and powerful class of methods people use for generating these samples is Markov Chain Monte Carlo (MCMC), but there are other options (e.g., brute-force or monte carlo rejection sampling). MCMC methods are useful because they scale reasonably to higher dimensions (well, at least better than brute-force). A disadvantage to these methods comes from the &ldquo;Markov Chain&rdquo; part of the name: there is always some correlation between nearby steps in a chain of samples, so you have to compute second-order statistics on the samples to try to verify whether your samples are truly random or fair samples from the target distribution (your posterior pdf).</p>
<p>The simplest MCMC algorithm is known as Metropolis-Hastings. I&rsquo;m not going to explain it in detail, but in pseudocode, it is:</p>
<ul>
<li>Start from some position in parameter space, <code>$\theta_0$</code> with posterior probability <code>$\pi_0$</code></li>
<li>Iterate from 1 to <code>$N_{\rm steps}$</code>:
<ul>
<li>Sample an offset from <code>$\delta\theta_0$</code> from some proposal distribution</li>
<li>Compute a new parameter value using this offset, <code>$\theta_{\rm new} = \theta_0 + \delta\theta_0$</code></li>
<li>Evaluate the posterior probability at the new new parameter vector, <code>$\pi_{\rm new}$</code></li>
<li>Sample a uniform random number, <code>$r \sim \mathcal{U}(0,1)$</code></li>
<li>if <code>$\pi_{\rm new}/\pi_0 &gt; 1$</code> or <code>$\pi_{\rm new}/\pi_0 &gt; r$</code>:
<ul>
<li>store <code>$\theta_{\rm new}$</code></li>
<li>replace <code>$\theta_0,\pi_0$</code> with <code>$\theta_{\rm new},\pi_{\rm new}$</code></li>
</ul>
</li>
<li>else:
<ul>
<li>store <code>$\theta_0$</code> again</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The proposal distribution has to be chosen and tuned by hand. We&rsquo;ll use a spherical / uncorrelated Gaussian distribution with root-variances set by hand:</p>
<pre><code class="language-python">def sample_proposal(*sigmas):
    return np.random.normal(0.0, sigmas)


def run_metropolis_hastings(p0, n_steps, model, proposal_sigmas):
    &quot;&quot;&quot;
    Run a Metropolis-Hastings MCMC sampler to generate samples from the input
    log-posterior function, starting from some initial parameter vector.

    Parameters
    ----------
    p0 : iterable
        Initial parameter vector.
    n_steps : int
        Number of steps to run the sampler for.
    model : StraightLineModel instance (or subclass)
        A callable object that takes a parameter vector and computes
        the log of the posterior pdf.
    proposal_sigmas : list, array
        A list of standard-deviations passed to the sample_proposal
        function. These are like step sizes in each of the parameters.
    &quot;&quot;&quot;
    p0 = np.array(p0)
    if len(proposal_sigmas) != len(p0):
        raise ValueError(
            &quot;Proposal distribution should have same shape as parameter vector.&quot;
        )

    # the objects we'll fill and return:
    chain = np.zeros((n_steps, len(p0)))  # parameter values at each step
    ln_probs = np.zeros(n_steps)  # log-probability values at each step

    # we'll keep track of how many steps we accept to compute the acceptance fraction
    n_accept = 0

    # evaluate the log-posterior at the initial position and store starting position in chain
    ln_probs[0] = model(p0)
    chain[0] = p0

    # loop through the number of steps requested and run MCMC
    for i in range(1, n_steps):
        # proposed new parameters
        step = sample_proposal(*proposal_sigmas)
        new_p = chain[i - 1] + step

        # compute log-posterior at new parameter values
        new_ln_prob = model(new_p)

        # log of the ratio of the new log-posterior to the previous log-posterior value
        ln_prob_ratio = new_ln_prob - ln_probs[i - 1]

        if (ln_prob_ratio &gt; 0) or (ln_prob_ratio &gt; np.log(np.random.uniform())):
            chain[i] = new_p
            ln_probs[i] = new_ln_prob
            n_accept += 1

        else:
            chain[i] = chain[i - 1]
            ln_probs[i] = ln_probs[i - 1]

    acc_frac = n_accept / n_steps
    return chain, ln_probs, acc_frac
</code></pre>
<p>Now we&rsquo;ll run the sampler! Let&rsquo;s start from some arbitrary position allowed by our prior.</p>
<h3 id="exercise-5">Exercise 5:</h3>
<p>Choose a starting position, values for <code>a</code> and <code>b</code> to start the MCMC from. In general, a good way to do this is to sample from the prior pdf. Generate values for <code>a</code> and <code>b</code> by sampling from a uniform distribution over the domain we defined above. Then, run the MCMC sampler from this initial position for 8192 steps. Play around with (&ldquo;tune&rdquo; as they say) the <code>proposal_sigmas</code> until you get an acceptance fraction around ~40%.</p>
<h4 id="solution-4">Solution:</h4>
<pre><code class="language-python">p0 = [6.0, 6.0]
chain, _, acc_frac = run_metropolis_hastings(
    p0, n_steps=8192, model=model, proposal_sigmas=[0.05, 0.05]
)
print(&quot;Acceptance fraction: {:.1%}&quot;.format(acc_frac))
</code></pre>
<pre><code>Acceptance fraction: 42.8%
</code></pre>
<p>Let&rsquo;s look at the chain returned, the parameter value positions throughout the sampler run:</p>
<pre><code class="language-python">fig, ax = plt.subplots(1, 1, figsize=(5, 5))

ax.pcolormesh(
    a_grid,
    b_grid,
    ln_post_vals,
    cmap=&quot;Blues&quot;,
    vmin=ln_post_vals.max() - 128,
    vmax=ln_post_vals.max(),
)  # arbitrary scale
ax.axis(&quot;tight&quot;)

fig.tight_layout()

ax.plot(a_true, b_true, marker=&quot;o&quot;, zorder=10, color=&quot;#de2d26&quot;)
ax.plot(chain[:512, 0], chain[:512, 1], marker=&quot;&quot;, color=&quot;k&quot;, linewidth=1.0)

ax.set_xlabel(&quot;$a$&quot;)
ax.set_ylabel(&quot;$b$&quot;)
</code></pre>
<pre><code>Text(40.83333333333333, 0.5, '$b$')
</code></pre>
<p><img src="output_45_1.png" alt="png"></p>
<p>We can also look at the individual parameter traces, i.e. the 1D functions of parameter value vs. step number for each parameter separately:</p>
<pre><code class="language-python">fig, axes = plt.subplots(len(p0), 1, figsize=(5, 7), sharex=True)

for i in range(len(p0)):
    axes[i].plot(chain[:, i], marker=&quot;&quot;, drawstyle=&quot;steps&quot;)

axes[0].axhline(a_true, color=&quot;r&quot;, label=&quot;true&quot;)
axes[0].legend(loc=&quot;best&quot;)
axes[0].set_ylabel(&quot;$a$&quot;)

axes[1].axhline(b_true, color=&quot;r&quot;)
axes[1].set_ylabel(&quot;$b$&quot;)

fig.tight_layout()
</code></pre>
<p><img src="output_47_0.png" alt="png"></p>
<p>From these trace plots, we can see by eye that it takes the sampler about a few hundred steps to converge. When we look at the samples returned or when we compute our summary statistics, we don&rsquo;t want to include these parameter values! In addition, there is likely some correlation between nearby steps. We can attempt to remove some of the correlated steps by <em>thinning</em> the chain, i.e. by downsampling. We can do both simultaneously using Python indexing tricks. Certainly by step 2000 the chains look converged, so from there on we&rsquo;ll keep only every 8th step:</p>
<pre><code class="language-python">good_samples = chain[2000::8]
good_samples.shape
</code></pre>
<pre><code>(774, 2)
</code></pre>
<p>We&rsquo;re left with 774 samples; we hope these are approximately uncorrelated, converged samples from the posterior pdf (there are other ways we can check, but these are out of scope for this workshop). Now you have to choose what summary statistics to report. You have some options, but a reasonable choice is to report the median, 16th, and 84th percentiles:</p>
<pre><code class="language-python">low, med, hi = np.percentile(good_samples, [16, 50, 84], axis=0)
upper, lower = hi - med, med - low

disp_str = &quot;&quot;
for i, name in enumerate([&quot;a&quot;, &quot;b&quot;]):
    fmt_str = &quot;{name}={val:.2f}^{{+{plus:.2f}}}_{{-{minus:.2f}}}&quot;
    disp_str += fmt_str.format(name=name, val=med[i], plus=upper[i], minus=lower[i])
    disp_str += r&quot;\quad &quot;

disp_str = &quot;${}$&quot;.format(disp_str)
display.Latex(data=disp_str)
</code></pre>
<p>$a=1.25^{+0.05}<em>{-0.05}\quad b=4.48^{+0.06}</em>{-0.05}\quad $</p>
<p>Recall that the true values are:</p>
<pre><code class="language-python">a_true, b_true
</code></pre>
<pre><code>(1.255, 4.507)
</code></pre>
<p>We&rsquo;ve now done this problem the Bayesian way as well! Now, instead of drawing the &ldquo;best-fit&rdquo; line over the data, we can take a handful of samples and plot a line for each of the samples, as a way to visualize the uncertainty we have in the model parameters:</p>
<pre><code class="language-python">plt.figure(figsize=(6, 5))
plt.errorbar(x, y, y_err, linestyle=&quot;none&quot;, marker=&quot;o&quot;, ecolor=&quot;#666666&quot;)

x_grid = np.linspace(x.min() - 0.1, x.max() + 0.1, 128)
for pars in good_samples[:128]:  # only plot 128 samples
    plt.plot(
        x_grid,
        line_model(pars, x_grid),
        marker=&quot;&quot;,
        linestyle=&quot;-&quot;,
        color=&quot;#3182bd&quot;,
        alpha=0.1,
        zorder=-10,
    )

plt.xlabel(&quot;$x$&quot;)
plt.ylabel(&quot;$y$&quot;)
plt.tight_layout()
</code></pre>
<p><img src="output_55_0.png" alt="png"></p>
<p>Or, we can plot the samples using a <em>corner plot</em> to visualize the structure of the 2D and 1D (marginal) posteriors:</p>
<pre><code class="language-python"># uncomment and run this line if the import fails:
# !source activate statsseminar; pip install corner
import corner
</code></pre>
<pre><code class="language-python">fig = corner.corner(
    chain[2000:], bins=32, labels=[&quot;$a$&quot;, &quot;$b$&quot;], truths=[a_true, b_true]
)
</code></pre>
<p><img src="output_58_0.png" alt="png"></p>
<hr>
<h2 id="finally-the-problem-you-came-here-for-fitting-a-straight-line-to-data-with-intrinsic-scatter">Finally, the problem you came here for: fitting a straight line to data with intrinsic scatter</h2>
<p>We made it! We&rsquo;re now ready to do the problem we set out to do. In the initial model, we assumed that we knew the uncertainties in our measurements exactly and that the data were drawn from a one-dimensional line. We&rsquo;re now going to relax that assumption and assume that either (a) the data uncertainties have been underestimated or (b) there is intrinsic scatter in the true model (in the absence of other information, these two ideas are degenerate). Let&rsquo;s first generate some data. We&rsquo;ll assume the latter of the two ideas, and we&rsquo;ll further assume that the model line is convolved with an additional Gaussian in the <code>$y$</code> direction, with the new parameter being the intrinsic width of the relation expressed as a variance <code>$V$</code>:</p>
<pre><code class="language-python">V_true = 0.5**2
n_data = 42

# we'll keep the same parameters for the line as we used above
</code></pre>
<pre><code class="language-python">x = rnd.uniform(0, 2.0, n_data)
x.sort()  # sort the values in place

y = a_true * x + b_true

# Heteroscedastic Gaussian uncertainties only in y direction
y_err = rnd.uniform(
    0.1, 0.2, size=n_data
)  # randomly generate uncertainty for each datum

# add Gaussian intrinsic width
y = rnd.normal(
    y, np.sqrt(y_err**2 + V_true)
)  # re-sample y data with noise and intrinsic scatter
</code></pre>
<pre><code class="language-python">plt.errorbar(x, y, y_err, linestyle=&quot;none&quot;, marker=&quot;o&quot;, ecolor=&quot;#666666&quot;)
plt.xlabel(&quot;$x$&quot;)
plt.ylabel(&quot;$y$&quot;)
plt.tight_layout()
</code></pre>
<p><img src="output_62_0.png" alt="png"></p>
<p>Let&rsquo;s first naively fit the data assuming no intrinsic scatter using least-squares:</p>
<pre><code class="language-python">X = np.vander(x, N=2, increasing=True)
Cov = np.diag(y_err**2)
Cinv = np.linalg.inv(Cov)
</code></pre>
<pre><code class="language-python">best_pars = np.linalg.inv(X.T @ Cinv @ X) @ (X.T @ Cinv @ y)
pars_Cov = np.linalg.inv(X.T @ Cinv @ X)
</code></pre>
<pre><code class="language-python">plt.errorbar(x, y, y_err, linestyle=&quot;none&quot;, marker=&quot;o&quot;, ecolor=&quot;#666666&quot;)

x_grid = np.linspace(x.min() - 0.1, x.max() + 0.1, 128)
plt.plot(
    x_grid,
    line_model(best_pars[::-1], x_grid),
    marker=&quot;&quot;,
    linestyle=&quot;-&quot;,
    label=&quot;best-fit line&quot;,
)
plt.plot(
    x_grid,
    line_model([a_true, b_true], x_grid),
    marker=&quot;&quot;,
    linestyle=&quot;-&quot;,
    label=&quot;true line&quot;,
)

plt.xlabel(&quot;$x$&quot;)
plt.ylabel(&quot;$y$&quot;)

plt.legend(loc=&quot;best&quot;)
plt.tight_layout()
</code></pre>
<p><img src="output_66_0.png" alt="png"></p>
<p>The covariance matrix for the parameters is:</p>
<pre><code class="language-python">pars_Cov
</code></pre>
<pre><code>array([[ 0.00173349, -0.00133591],
       [-0.00133591,  0.00143021]])
</code></pre>
<p>We clearly get a biased result and yet <em>very</em> precise measurements of the parameters when we don&rsquo;t take in to account the intrinsic scatter. What we need to do now is modify out model to include the scatter as a free parameter. Unfortunately, it enters the model non-linearly so there is no solution using linear algebra or least-squares. Instead, we just write a new likelihood function and optimize it numerically. One choice we&rsquo;ll make is to use the parameter <code>$\ln{V}$</code> instead of <code>$V$</code> for reasons I&rsquo;ll explain later. To implement the new model, we&rsquo;ll subclass our <code>StraightLineModel</code> class and define new likelihood and prior functions.</p>
<h3 id="exercise-6">Exercise 6:</h3>
<p>Subclass the <code>StraightLineModel</code> class and implement new prior and likelihood functions (<code>ln_prior</code> and <code>ln_likelihood</code>). The our model will now have 3 parameters: <code>a</code>, <code>b</code>, and <code>lnV</code> the log of the intrinsic scatter variance. Use flat priors on all of these parameters. In fact, we&rsquo;ll be even lazier and forget the constant normalization terms: if a parameter vector is within the ranges below, return 0. (log(1.)) otherwise return -infinity:</p>
<h4 id="solution-5">Solution:</h4>
<pre><code class="language-python">class StraightLineIntrinsicScatterModel(StraightLineModel):
    def ln_prior(self, pars):
        &quot;&quot;&quot;The prior only depends on the parameters&quot;&quot;&quot;

        a, b, lnV = pars

        # flat priors on a, b, lnV
        if a &lt; -10 or a &gt; 10 or b &lt; -100.0 or b &gt; 100.0 or lnV &lt; -10.0 or lnV &gt; 10.0:
            return -np.inf

        # this is only valid up to a numerical constant
        return 0.0

    def ln_likelihood(self, pars):
        &quot;&quot;&quot;The likelihood function evaluation requires a particular set of model parameters and the data&quot;&quot;&quot;
        a, b, lnV = pars
        V = np.exp(lnV)

        N = len(y)
        dy = y - line_model([a, b], self.x)
        ivar = 1 / (
            self.y_err**2 + V
        )  # inverse-variance now includes intrinsic scatter
        return -0.5 * (
            N * np.log(2 * np.pi) - np.sum(np.log(ivar)) + np.sum(dy**2 * ivar)
        )
</code></pre>
<pre><code class="language-python">scatter_model = StraightLineIntrinsicScatterModel(x, y, y_err)
</code></pre>
<pre><code class="language-python">x0 = [5.0, 5.0, 0.0]  # starting guess for the optimizer

# we have to minimize the negative log-likelihood to maximize the likelihood
result_ml_scatter = minimize(
    lambda *args: -scatter_model.ln_likelihood(*args), x0=x0, method=&quot;BFGS&quot;
)
result_ml_scatter
</code></pre>
<pre><code>      fun: 31.309507831773043
 hess_inv: array([[ 0.01842724, -0.01708872, -0.00015224],
       [-0.01708872,  0.02191525,  0.00019405],
       [-0.00015224,  0.00019405,  0.05771309]])
      jac: array([2.38418579e-07, 1.19209290e-06, 4.76837158e-07])
  message: 'Optimization terminated successfully.'
     nfev: 108
      nit: 17
     njev: 27
   status: 0
  success: True
        x: array([ 1.12344769,  4.63858875, -1.44568252])
</code></pre>
<pre><code class="language-python">plt.errorbar(x, y, y_err, linestyle=&quot;none&quot;, marker=&quot;o&quot;, ecolor=&quot;#666666&quot;)

x_grid = np.linspace(x.min() - 0.1, x.max() + 0.1, 128)
plt.plot(
    x_grid,
    line_model(result_ml_scatter.x[:2], x_grid),
    marker=&quot;&quot;,
    linestyle=&quot;-&quot;,
    label=&quot;best-fit line&quot;,
)
plt.plot(
    x_grid,
    line_model([a_true, b_true], x_grid),
    marker=&quot;&quot;,
    linestyle=&quot;-&quot;,
    label=&quot;true line&quot;,
)

plt.xlabel(&quot;$x$&quot;)
plt.ylabel(&quot;$y$&quot;)

plt.legend(loc=&quot;best&quot;)
plt.tight_layout()
</code></pre>
<p><img src="output_73_0.png" alt="png"></p>
<pre><code class="language-python">V_true, np.exp(result_ml_scatter.x[2])
</code></pre>
<pre><code>(0.25, 0.23558523044282928)
</code></pre>
<p>It looks like the maximum likelihood estimate is a little bit better, and we get a reasonable measurement of the intrinsic scatter, but none of this gives us a handle on the uncertainty. How do we quantify the uncertainty in the now 3 parameters? We&rsquo;ll just run MCMC.</p>
<h3 id="exercise-7">Exercise 7:</h3>
<p>To quantify our uncertainty in the parameters, we&rsquo;ll run MCMC using the new model. Run MCMC for 65536 steps and visualize the resulting chain. Make sure the acceptance fraction is between ~25-50%.</p>
<h4 id="solution-6">Solution:</h4>
<pre><code class="language-python">p0 = [6.0, 6.0, -1.0]
chain, _, acc_frac = run_metropolis_hastings(
    p0, n_steps=2**16, model=scatter_model, proposal_sigmas=[0.15, 0.15, 0.2]
)
acc_frac
</code></pre>
<pre><code>0.3107147216796875
</code></pre>
<pre><code class="language-python">fig, axes = plt.subplots(len(p0), 1, figsize=(5, 7), sharex=True)

for i in range(len(p0)):
    axes[i].plot(chain[:, i], marker=&quot;&quot;, drawstyle=&quot;steps&quot;)

axes[0].axhline(a_true, color=&quot;r&quot;, label=&quot;true&quot;)
axes[0].legend(loc=&quot;best&quot;)
axes[0].set_ylabel(&quot;$a$&quot;)

axes[1].axhline(b_true, color=&quot;r&quot;)
axes[1].set_ylabel(&quot;$b$&quot;)

axes[2].axhline(np.log(V_true), color=&quot;r&quot;)
axes[2].set_ylabel(r&quot;$\ln V$&quot;)

fig.tight_layout()
</code></pre>
<p><img src="output_77_0.png" alt="png"></p>
<pre><code class="language-python">fig = corner.corner(
    chain[2000:],
    bins=32,
    labels=[&quot;$a$&quot;, &quot;$b$&quot;, r&quot;$\ln V$&quot;],
    truths=[a_true, b_true, np.log(V_true)],
)
</code></pre>
<p><img src="output_78_0.png" alt="png"></p>
<p>Now we&rsquo;ll again compute the percentiles for the 1D, marginal distributions:</p>
<pre><code class="language-python">good_samples = chain[2000::8]
good_samples.shape
</code></pre>
<pre><code>(7942, 3)
</code></pre>
<pre><code class="language-python">low, med, hi = np.percentile(good_samples, [16, 50, 84], axis=0)
upper, lower = hi - med, med - low

disp_str = &quot;&quot;
for i, name in enumerate([&quot;a&quot;, &quot;b&quot;, r&quot;\ln V&quot;]):
    fmt_str = &quot;{name}={val:.2f}^{{+{plus:.2f}}}_{{-{minus:.2f}}}&quot;
    disp_str += fmt_str.format(name=name, val=med[i], plus=upper[i], minus=lower[i])
    disp_str += r&quot;\quad &quot;

disp_str = &quot;${}$&quot;.format(disp_str)
display.Latex(data=disp_str)
</code></pre>
<p>$a=1.12^{+0.15}<em>{-0.14}\quad b=4.64^{+0.15}</em>{-0.16}\quad \ln V=-1.38^{+0.26}_{-0.24}\quad $</p>
<p>Compare this to the diagonal elements of the covariance matrix we got from ignoring the intrinsic scatter and doing least-squares fitting:</p>
<pre><code class="language-python">disp_str = &quot;&quot;
for i, name in zip([1, 0], [&quot;a&quot;, &quot;b&quot;]):
    fmt_str = r&quot;{name}={val:.2f} \pm {err:.2f}&quot;
    disp_str += fmt_str.format(name=name, val=best_pars[i], err=np.sqrt(pars_Cov[i, i]))
    disp_str += r&quot;\quad &quot;

disp_str = &quot;${}$&quot;.format(disp_str)
display.Latex(data=disp_str)
</code></pre>
<p>$a=1.13 \pm 0.04\quad b=4.65 \pm 0.04\quad $</p>
<p>The parameter uncertainties estimated from the MCMC samples are much larger &ndash; this reflects our uncertainty about the intrinsic scatter of the points. Precision is highly model dependent.</p>

  </div>
</section>


<footer class="text-center footer">
  <hr />
  
  <h6 class="text-center copyright">© 2015-2024 Adrian Price-Whelan</h6>
  
  <h6 class="text-center extra-footer">Reach me at <a href="mailto:adrianmpw@gmail.com">adrianmpw@gmail.com</a></h6>
  
  
</footer>

</div>


  
    
      
    
  


<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="../../js/main.js"></script>
<script src="../../js/custom.js"></script>



  
  <script src="https://unpkg.com/prismjs@1.20.0/components/prism-core.min.js"></script>

  
  <script src="https://unpkg.com/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js"
    data-autoloader-path="https://unpkg.com/prismjs@1.20.0/components/"></script>




</body>
</html>


